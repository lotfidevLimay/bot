"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeThemes = exports.mergeStyles = exports.mergeAnimations = exports.mergeStaticStyles = exports.mergeFontFaces = exports.mergeThemeStyles = exports.mergeThemeVariables = exports.mergeThemeVariables__DEV = exports.mergeThemeVariables__PROD = exports.mergeSiteVariables = exports.mergeSiteVariables__DEV = exports.mergeSiteVariables__PROD = exports.mergeComponentVariables = exports.mergeComponentVariables__DEV = exports.mergeComponentVariables__PROD = exports.mergeComponentStyles = exports.mergeComponentStyles__DEV = exports.mergeComponentStyles__PROD = exports.emptyTheme = void 0;
var _ = require("lodash");
var callable_1 = require("./callable");
var debugEnabled_1 = require("./debugEnabled");
var deepmerge_1 = require("./deepmerge");
var objectKeysToValues_1 = require("./objectKeysToValues");
var withDebugId_1 = require("./withDebugId");
exports.emptyTheme = {
    siteVariables: {
        fontSizes: {},
    },
    componentVariables: {},
    componentStyles: {},
    fontFaces: [],
    staticStyles: [],
    animations: {},
};
// ----------------------------------------
// Component level merge functions
// ----------------------------------------
/**
 * Merges a single component's styles (keyed by component part) with another component's styles.
 */
var mergeComponentStyles__PROD = function (stylesA, stylesB) {
    var result = {};
    if (stylesA) {
        Object.keys(stylesA).forEach(function (partName) {
            var slotA = stylesA[partName];
            var slotB = stylesB === null || stylesB === void 0 ? void 0 : stylesB[partName];
            // if there is no source, merging is a no-op, skip it
            if (typeof slotA === 'undefined' || slotA === null) {
                return;
            }
            // no target means source doesn't need to merge onto anything
            // just ensure source is callable (prepared format)
            if (typeof slotB === 'undefined' || slotB === null) {
                result[partName] = typeof slotA === 'function' ? slotA : function () { return slotA; };
                return;
            }
            if (slotA === slotB) {
                result[partName] = typeof slotA === 'function' ? slotA : function () { return slotA; };
            }
        });
    }
    if (stylesB) {
        Object.keys(stylesB).forEach(function (partName) {
            var slotA = stylesA === null || stylesA === void 0 ? void 0 : stylesA[partName];
            var slotB = stylesB[partName];
            // if there is no source, merging is a no-op, skip it
            if (typeof slotB === 'undefined' || slotB === null) {
                return;
            }
            // no target means source doesn't need to merge onto anything
            // just ensure source is callable (prepared format)
            if (typeof slotA === 'undefined' || slotA === null) {
                result[partName] = typeof slotB === 'function' ? slotB : function () { return slotB; };
                return;
            }
            if (slotA === slotB) {
                return;
            }
            // We have both target and source, replace with merge fn
            result[partName] = function mergedStyleFunction(styleParam) {
                // originalTarget is always prepared, fn is guaranteed
                return _.merge(typeof slotA === 'function' ? slotA(styleParam) : slotA, typeof slotB === 'function' ? slotB(styleParam) : slotB);
            };
        });
    }
    return result;
};
exports.mergeComponentStyles__PROD = mergeComponentStyles__PROD;
var mergeComponentStyles__DEV = function (stylesA, stylesB) {
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentStyles__PROD(stylesA, stylesB);
    }
    var mergedKeys = __spreadArray(__spreadArray([], (stylesA ? Object.keys(stylesA) : [])), (stylesB ? Object.keys(stylesB) : []));
    var result = {};
    mergedKeys.forEach(function (slotName) {
        var slotA = function (styleParam) {
            var _a = callable_1.callable(stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName])(styleParam) || {}, _b = _a._debug, _debug = _b === void 0 ? undefined : _b, styles = __rest(_a, ["_debug"]);
            // new object required to prevent circular JSON structure error in <Debug />
            return __assign(__assign({}, styles), { _debug: _debug || [{ styles: __assign({}, styles), debugId: stylesA === null || stylesA === void 0 ? void 0 : stylesA._debugId }] });
        };
        var slotB = function (styleParam) {
            var _a = callable_1.callable(stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName])(styleParam) || {}, _b = _a._debug, _debug = _b === void 0 ? undefined : _b, styles = __rest(_a, ["_debug"]);
            // new object required to prevent circular JSON structure error in <Debug />
            return __assign(__assign({}, styles), { _debug: _debug || [{ styles: __assign({}, styles), debugId: stylesB === null || stylesB === void 0 ? void 0 : stylesB._debugId }] });
        };
        if ((stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName]) && (stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName])) {
            // We have both, replace with merge fn
            result[slotName] = function (styleParam) {
                // slot* are always prepared, fn is guaranteed, _debug always exists
                var _a = slotA(styleParam), debugA = _a._debug, resolvedStylesA = __rest(_a, ["_debug"]);
                var _b = slotB(styleParam), debugB = _b._debug, resolvedStylesB = __rest(_b, ["_debug"]);
                var merged = _.merge(resolvedStylesA, resolvedStylesB);
                merged._debug = debugA.concat(debugB || { styles: resolvedStylesB, debugId: resolvedStylesB._debugId });
                return merged;
            };
        }
        else if (stylesA === null || stylesA === void 0 ? void 0 : stylesA[slotName]) {
            result[slotName] = slotA;
        }
        else if (stylesB === null || stylesB === void 0 ? void 0 : stylesB[slotName]) {
            result[slotName] = slotB;
        }
    });
    return result;
};
exports.mergeComponentStyles__DEV = mergeComponentStyles__DEV;
exports.mergeComponentStyles = process.env.NODE_ENV === 'production' ? exports.mergeComponentStyles__PROD : exports.mergeComponentStyles__DEV;
/**
 * Merges a single component's variables with another component's variables.
 */
var mergeComponentVariables__PROD = function (variablesA, variablesB) {
    if (variablesA && variablesB) {
        return function mergedComponentVariables(siteVariables) {
            var resolvedVariablesA = typeof variablesA === 'function' ? variablesA(siteVariables) : variablesA || {};
            var resolvedVariablesB = typeof variablesB === 'function' ? variablesB(siteVariables) : variablesB || {};
            return deepmerge_1.deepmerge(resolvedVariablesA, resolvedVariablesB);
        };
    }
    if (variablesA) {
        return typeof variablesA === 'function' ? variablesA : function () { return variablesA || {}; };
    }
    if (variablesB) {
        return typeof variablesB === 'function' ? variablesB : function () { return variablesB || {}; };
    }
    return function () { return ({}); };
};
exports.mergeComponentVariables__PROD = mergeComponentVariables__PROD;
var mergeComponentVariables__DEV = function (variablesA, variablesB) {
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentVariables__PROD(variablesA, variablesB);
    }
    var initial = function () { return ({}); };
    return [variablesA, variablesB].reduce(function (acc, next) {
        return function (siteVariables) {
            var _a = acc(siteVariables), _b = _a._debug, _debug = _b === void 0 ? [] : _b, accumulatedVariables = __rest(_a, ["_debug"]);
            var _c = callable_1.callable(next)(siteVariables) || {}, _d = _c._debug, computedDebug = _d === void 0 ? undefined : _d, _e = _c._debugId, _debugId = _e === void 0 ? undefined : _e, computedComponentVariables = __rest(_c, ["_debug", "_debugId"]);
            var merged = deepmerge_1.deepmerge(accumulatedVariables, computedComponentVariables);
            merged._debug = _debug.concat(computedDebug || {
                resolved: computedComponentVariables,
                debugId: _debugId,
                input: siteVariables
                    ? siteVariables._invertedKeys && callable_1.callable(next)(siteVariables._invertedKeys)
                    : callable_1.callable(next)(),
            });
            return merged;
        };
    }, initial);
};
exports.mergeComponentVariables__DEV = mergeComponentVariables__DEV;
exports.mergeComponentVariables = process.env.NODE_ENV === 'production' ? exports.mergeComponentVariables__PROD : exports.mergeComponentVariables__DEV;
// ----------------------------------------
// Theme level merge functions
// ----------------------------------------
/**
 * Site variables can safely be merged at each Provider in the tree.
 * They are flat objects and do not depend on render-time values, such as props.
 */
var mergeSiteVariables__PROD = function (siteVariablesA, siteVariablesB) {
    var initial = {
        fontSizes: {},
    };
    if (siteVariablesA && siteVariablesB) {
        return deepmerge_1.deepmerge(initial, siteVariablesA, siteVariablesB);
    }
    if (siteVariablesA) {
        return __assign(__assign({}, initial), siteVariablesA);
    }
    return __assign(__assign({}, initial), siteVariablesB);
};
exports.mergeSiteVariables__PROD = mergeSiteVariables__PROD;
var mergeSiteVariables__DEV = function (siteVariablesA, siteVariablesB) {
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeSiteVariables__PROD(siteVariablesA, siteVariablesB);
    }
    var initial = {
        fontSizes: {},
    };
    return [siteVariablesA, siteVariablesB].reduce(function (acc, next) {
        var _a = acc._debug, _debug = _a === void 0 ? [] : _a, accumulatedSiteVariables = __rest(acc, ["_debug"]);
        var _b = next || {}, _c = _b._debug, computedDebug = _c === void 0 ? undefined : _c, _d = _b._invertedKeys, _invertedKeys = _d === void 0 ? undefined : _d, _e = _b._debugId, _debugId = _e === void 0 ? undefined : _e, nextSiteVariables = __rest(_b, ["_debug", "_invertedKeys", "_debugId"]);
        var merged = deepmerge_1.deepmerge(__assign(__assign({}, accumulatedSiteVariables), { _invertedKeys: undefined }), nextSiteVariables);
        merged._debug = _debug.concat(computedDebug || { resolved: nextSiteVariables, debugId: _debugId });
        merged._invertedKeys = _invertedKeys || objectKeysToValues_1.objectKeyToValues(merged, function (key) { return "siteVariables." + key; });
        return merged;
    }, initial);
};
exports.mergeSiteVariables__DEV = mergeSiteVariables__DEV;
exports.mergeSiteVariables = process.env.NODE_ENV === 'production' ? exports.mergeSiteVariables__PROD : exports.mergeSiteVariables__DEV;
/**
 * Component variables can be objects, functions, or an array of these.
 * The functions must be called with the final result of siteVariables, otherwise
 *   the component variable objects would have no ability to apply siteVariables.
 * Therefore, componentVariables must be resolved by the component at render time.
 * We instead pass down call stack of component variable functions to be resolved later.
 */
var mergeThemeVariables__PROD = function (themeComponentVariablesA, themeComponentVariablesB) {
    if (themeComponentVariablesA && themeComponentVariablesB) {
        var displayNames = _.union.apply(_, _.map([themeComponentVariablesA, themeComponentVariablesB], _.keys));
        return displayNames.reduce(function (componentVariables, displayName) {
            componentVariables[displayName] = exports.mergeComponentVariables(themeComponentVariablesA[displayName], themeComponentVariablesB[displayName]);
            return componentVariables;
        }, {});
    }
    if (themeComponentVariablesA) {
        return Object.fromEntries(Object.entries(themeComponentVariablesA).map(function (_a) {
            var displayName = _a[0], variables = _a[1];
            return [displayName, exports.mergeComponentVariables(undefined, variables)];
        }));
    }
    if (themeComponentVariablesB) {
        return Object.fromEntries(Object.entries(themeComponentVariablesB).map(function (_a) {
            var displayName = _a[0], variables = _a[1];
            return [displayName, exports.mergeComponentVariables(undefined, variables)];
        }));
    }
    return {};
};
exports.mergeThemeVariables__PROD = mergeThemeVariables__PROD;
var mergeThemeVariables__DEV = function (themeComponentVariablesA, themeComponentVariablesB) {
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeThemeVariables__PROD(themeComponentVariablesA, themeComponentVariablesB);
    }
    var displayNames = _.union.apply(_, _.map([themeComponentVariablesA, themeComponentVariablesB], _.keys));
    return displayNames.reduce(function (componentVariables, displayName) {
        componentVariables[displayName] = exports.mergeComponentVariables(themeComponentVariablesA && withDebugId_1.withDebugId(themeComponentVariablesA[displayName], themeComponentVariablesA._debugId), themeComponentVariablesB && withDebugId_1.withDebugId(themeComponentVariablesB[displayName], themeComponentVariablesB._debugId));
        return componentVariables;
    }, {});
};
exports.mergeThemeVariables__DEV = mergeThemeVariables__DEV;
exports.mergeThemeVariables = process.env.NODE_ENV === 'production' ? exports.mergeThemeVariables__PROD : exports.mergeThemeVariables__DEV;
/**
 * See mergeThemeVariables() description.
 * Component styles adhere to the same pattern as component variables, except
 *   that they return style objects.
 */
var mergeThemeStyles__PROD = function (themeComponentStylesA, themeComponentStylesB) {
    if (themeComponentStylesA && themeComponentStylesB) {
        var displayNames = _.union.apply(_, _.map([themeComponentStylesA, themeComponentStylesB], _.keys));
        return displayNames.reduce(function (themeComponentStyles, displayName) {
            themeComponentStyles[displayName] = exports.mergeComponentStyles(themeComponentStylesA[displayName], themeComponentStylesB[displayName]);
            return themeComponentStyles;
        }, {});
    }
    if (themeComponentStylesA) {
        return Object.fromEntries(Object.entries(themeComponentStylesA).map(function (_a) {
            var displayName = _a[0], styles = _a[1];
            return [displayName, exports.mergeComponentStyles(undefined, styles)];
        }));
    }
    if (themeComponentStylesB) {
        return Object.fromEntries(Object.entries(themeComponentStylesB).map(function (_a) {
            var displayName = _a[0], styles = _a[1];
            return [displayName, exports.mergeComponentStyles(undefined, styles)];
        }));
    }
    return {};
};
var mergeThemeStyles__DEV = function (componentStylesA, componentStylesB) {
    if (!debugEnabled_1.isEnabled) {
        return mergeThemeStyles__PROD(componentStylesA, componentStylesB);
    }
    var initial = {};
    return [componentStylesA, componentStylesB].reduce(function (themeComponentStyles, next) {
        _.forEach(next, function (stylesByPart, displayName) {
            themeComponentStyles[displayName] = exports.mergeComponentStyles(themeComponentStyles[displayName], withDebugId_1.withDebugId(stylesByPart, next._debugId));
        });
        return themeComponentStyles;
    }, initial);
};
exports.mergeThemeStyles = process.env.NODE_ENV === 'production' ? mergeThemeStyles__PROD : mergeThemeStyles__DEV;
var mergeFontFaces = function (fontFacesA, fontFacesB) {
    return __spreadArray(__spreadArray([], (fontFacesA || [])), (fontFacesB || []));
};
exports.mergeFontFaces = mergeFontFaces;
var mergeStaticStyles = function (staticStylesA, staticStylesB) {
    return __spreadArray(__spreadArray([], (staticStylesA || [])), (staticStylesB || []));
};
exports.mergeStaticStyles = mergeStaticStyles;
var mergeAnimations = function (animationsA, animationsB) {
    return __assign(__assign({}, animationsA), animationsB);
};
exports.mergeAnimations = mergeAnimations;
var mergeStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return sources.reduce(function (acc, next) {
            return _.merge(acc, callable_1.callable(next).apply(void 0, args));
        }, {});
    };
};
exports.mergeStyles = mergeStyles;
var mergeThemes = function (themeA, themeB) {
    var debugIdA = themeA === null || themeA === void 0 ? void 0 : themeA['_debugId'];
    var debugIdB = themeB === null || themeB === void 0 ? void 0 : themeB['_debugId'];
    if (themeA && themeB) {
        return {
            animations: exports.mergeAnimations(themeA.animations, themeB.animations),
            componentVariables: exports.mergeThemeVariables(withDebugId_1.withDebugId(themeA.componentVariables, debugIdA), withDebugId_1.withDebugId(themeB.componentVariables, debugIdB)),
            componentStyles: exports.mergeThemeStyles(withDebugId_1.withDebugId(themeA.componentStyles, debugIdA), withDebugId_1.withDebugId(themeB.componentStyles, debugIdB)),
            fontFaces: exports.mergeFontFaces(themeA.fontFaces, themeB.fontFaces),
            siteVariables: exports.mergeSiteVariables(withDebugId_1.withDebugId(themeA.siteVariables, debugIdA), withDebugId_1.withDebugId(themeB.siteVariables, debugIdB)),
            staticStyles: exports.mergeStaticStyles(themeA.staticStyles, themeB.staticStyles),
        };
    }
    if (themeA) {
        return {
            animations: exports.mergeAnimations(undefined, themeA.animations),
            componentVariables: exports.mergeThemeVariables(undefined, withDebugId_1.withDebugId(themeA.componentVariables, debugIdA)),
            componentStyles: exports.mergeThemeStyles(undefined, withDebugId_1.withDebugId(themeA.componentStyles, debugIdA)),
            fontFaces: exports.mergeFontFaces(undefined, themeA.fontFaces),
            siteVariables: exports.mergeSiteVariables(undefined, withDebugId_1.withDebugId(themeA.siteVariables, debugIdA)),
            staticStyles: exports.mergeStaticStyles(undefined, themeA.staticStyles),
        };
    }
    if (themeB) {
        return {
            animations: exports.mergeAnimations(undefined, themeB.animations),
            componentVariables: exports.mergeThemeVariables(undefined, withDebugId_1.withDebugId(themeB.componentVariables, debugIdB)),
            componentStyles: exports.mergeThemeStyles(undefined, withDebugId_1.withDebugId(themeB.componentStyles, debugIdB)),
            fontFaces: exports.mergeFontFaces(undefined, themeB.fontFaces),
            siteVariables: exports.mergeSiteVariables(undefined, withDebugId_1.withDebugId(themeB.siteVariables, debugIdB)),
            staticStyles: exports.mergeStaticStyles(undefined, themeB.staticStyles),
        };
    }
    return __assign({}, exports.emptyTheme);
};
exports.mergeThemes = mergeThemes;
