"use strict";
// Copyright (c) Wictor WilÃ©n. All rights reserved.
// Licensed under the MIT license.
// SPDX-License-Identifier: MIT
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployTask = void 0;
const fancy_log_1 = __importDefault(require("fancy-log"));
const execute_1 = require("./execute");
const through2_1 = __importDefault(require("through2"));
const jszip_1 = __importDefault(require("jszip"));
const plugin_error_1 = __importDefault(require("plugin-error"));
const fs_extra_1 = require("fs-extra");
const _1 = require(".");
const chalk_1 = __importDefault(require("chalk"));
const argv = require("yargs").argv;
const deployTask = (gulp, config) => {
    // Updates an existing application
    const update = (cb, id, filename) => (0, execute_1.execute)(["teams", "app", "update", "--id", id, "--filePath", filename, "-o", "json"], chunk => (0, fancy_log_1.default)(`${chunk}`), chunk => cb(new Error(chunk)), code => {
        if (code === 0) {
            (0, _1.trackEvent)("application-updated");
            (0, fancy_log_1.default)("Application updated!");
            cb();
        }
        else {
            cb(new plugin_error_1.default("yoteams-deploy", "Application deployment failed"));
        }
    });
    // Lists and gets the current application based on the external id
    const list = (cb, filename) => (0, execute_1.execute)(["teams", "app", "list", "-o", "json"], chunk => {
        const result = (Buffer.from(chunk).toString("utf-8"));
        const json = JSON.parse(result);
        const app = json.find((x) => x.externalId === process.env.APPLICATION_ID);
        if (app) {
            update(cb, app.id, filename);
        }
        else {
            cb(new plugin_error_1.default("yoteams-deploy", "Application not found in Teams App store"));
        }
    }, chunk => cb(new plugin_error_1.default("yoteams-deploy", chunk)));
    // publishes the application
    const publish = (cb, filename) => (0, execute_1.execute)(["teams", "app", "publish", "--filePath", filename, "-o", "json"], chunk => (0, fancy_log_1.default)(`${chunk}`), chunk => {
        const err = (Buffer.from(chunk).toString("utf-8"));
        if (err.indexOf("App with same id already exists in the tenant.") >= 0) {
            list(cb, filename);
        }
        else {
            cb(new plugin_error_1.default("yoteams-deploy", err));
        }
    }, code => {
        if (code === 0) {
            (0, _1.trackEvent)("application-published");
            (0, fancy_log_1.default)("Application published to Teams App store!");
            cb();
        }
    });
    // logs in
    const login = (cb) => (0, execute_1.execute)(["login"], chunk => (0, fancy_log_1.default)(`${chunk}`), chunk => (0, fancy_log_1.default)(`${chunk}`), code => code === 0 ? cb() : cb(new plugin_error_1.default("yoteams-deploy", "Error logging in!")));
    const logout = (cb) => (0, execute_1.execute)(["logout"], chunk => (0, fancy_log_1.default)(`${chunk}`), chunk => (0, fancy_log_1.default)(`${chunk}`), code => code === 0 ? cb() : cb(new plugin_error_1.default("yoteams-deploy", "Error logging out!")));
    const status = (cb) => (0, execute_1.execute)(["status"], chunk => {
        const result = (Buffer.from(chunk).toString("utf-8"));
        if (result.startsWith("Logged out")) {
            login(cb);
        }
        else {
            (0, fancy_log_1.default)("Already signed in!");
            cb();
        }
    }, chunk => cb(new plugin_error_1.default("yoteams-deploy", chunk)), code => {
        if (code !== 0) {
            cb(new plugin_error_1.default("yoteams-deploy", "Error checking m365 status"));
        }
    });
    status.displayName = "tenant:login";
    function publishFn() {
        function p(file, enc, callback) {
            if (!file.contents) {
                throw new Error("Invalid file");
            }
            jszip_1.default.loadAsync((0, fs_extra_1.readFileSync)("package/" + file.basename)).then(zip => {
                var _a;
                const manifest = (_a = zip.file("manifest.json")) === null || _a === void 0 ? void 0 : _a.async("string").then(data => {
                    const json = JSON.parse(data);
                    const id = json.id;
                    if (id === process.env.APPLICATION_ID) {
                        // only publish the one with the current application id
                        publish(callback, "package/" + file.basename);
                    }
                    else {
                        callback();
                    }
                });
            });
        }
        return through2_1.default.obj(p, (callback) => { callback(); });
    }
    function publishTask() {
        (0, _1.trackEvent)("publish");
        return gulp.src("./package/*.zip").pipe(publishFn());
    }
    publishTask.displayName = "tenant:application-upload";
    gulp.task("tenant:publish", (0, _1.dependencies)(gulp, "tenant:publish", status, publishTask));
    gulp.task("tenant:deploy", (0, _1.dependencies)(gulp, "tenant:deploy", "manifest", "tenant:publish"));
    // Replace the default serve with a new command
    gulp.task("serve", (cb) => {
        if (argv.publish) {
            (0, _1.dependencies)(gulp, "serve:deploy", "nuke", "tenant:deploy", "build", "nodemon", "watch")(() => { cb(); });
        }
        else {
            (0, _1.dependencies)(gulp, "serve", "nuke", "manifest", "build", "nodemon", "watch")(() => { cb(); });
        }
    });
    // Replace the default ngrok-serve with a new command
    gulp.task("ngrok-serve", (cb) => {
        (0, _1.dependencies)(gulp, "ngrok-serve", "start-ngrok", "serve")(() => { cb(); });
    });
    if (process.env.CODESPACES) {
        try {
            // only register code spaces tasks when in Github Codespaces
            const codespaceEnvConfig = "/workspaces/.codespaces/shared/environment-variables.json";
            const codespaceEnv = (0, fs_extra_1.readJSONSync)(codespaceEnvConfig);
            const codespaceName = codespaceEnv.CODESPACE_NAME;
            process.env.PUBLIC_HOSTNAME = `${codespaceName}-${process.env.PORT}.githubpreview.dev`;
            (0, fancy_log_1.default)("[Codespace] Public url: " + process.env.PUBLIC_HOSTNAME);
            gulp.task("codespaces-serve", (0, _1.dependencies)(gulp, "codespaces-serve", "serve"));
        }
        catch (ex) {
            (0, fancy_log_1.default)(chalk_1.default.red(`Unable to set up Codespaces tasks: ${ex}`));
        }
    }
    gulp.task("tenant:logout", (cb) => {
        logout(cb);
    });
};
exports.deployTask = deployTask;
