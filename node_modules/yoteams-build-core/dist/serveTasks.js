"use strict";
// Copyright (c) Wictor WilÃ©n. All rights reserved.
// Licensed under the MIT license.
// SPDX-License-Identifier: MIT
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveTasks = void 0;
const fancy_log_1 = __importDefault(require("fancy-log"));
const nodemon_1 = __importDefault(require("nodemon"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const child_process_1 = require("child_process");
const webTasks_1 = require("./webTasks");
const _1 = require(".");
const argv = require("yargs").argv;
const debug = argv.debug !== undefined;
const serveTasks = (gulp, config) => {
    const watches = [
        "./src/server/**/*.*"
    ];
    const clientWatches = [
        "./src/client/**/*.*",
        "!./src/**/*.scss"
    ];
    const staticFilesWatches = [
        "./src/public/**/*.html",
        "./src/public/**/*.ejs",
        "./src/public/assets/**/*"
    ];
    const injectSourceFiles = [
        "./dist/public/scripts/**/*.js",
        "./dist/public/styles/**/*.css"
    ];
    // Task that reloads the environment variables
    const reloadEnv = () => {
        (0, fancy_log_1.default)("Reloading environment");
        const env = argv.env;
        const dotenv = require("dotenv");
        const envConfig = dotenv.parse(fs_1.default.readFileSync(env ? path_1.default.resolve(process.cwd(), env) : ".env"));
        for (const k in envConfig) {
            if (k !== "PUBLIC_HOSTNAME") { // overwrite all but PUBLIC_HOSTNAME as that can be set by ngrok/codespaces
                process.env[k] = envConfig[k];
            }
        }
        return Promise.resolve();
    };
    // restart nodemon task
    const nodemonRestart = () => { nodemon_1.default.restart(); return Promise.resolve(); };
    // Webpack dev server for client side rebuilds
    let webpackDevServerProcess;
    const restartDevServer = () => {
        if (webpackDevServerProcess) {
            const killed = webpackDevServerProcess.kill("SIGINT");
            if (!killed) {
                throw new Error("Unable to stop webpack dev server. Please restart the last command.");
            }
        }
        startWebpackDevServer();
        return Promise.resolve();
    };
    const startWebpackDevServer = () => {
        webpackDevServerProcess = (0, child_process_1.fork)(path_1.default.resolve(__dirname, "./webpackServe"), process.argv.slice(2), {
            stdio: "inherit"
        });
    };
    /**
     * Register watches
     */
    const registerWatches = () => {
        var _a;
        // all other watches
        gulp.watch(config.watches ? watches.concat(config.watches) : watches, gulp.series("webpack:server"));
        if (debug) {
            // webpack dev server - incrementally rebuilds client bundle on source change
            startWebpackDevServer();
        }
        else {
            gulp.watch(config.clientWatches ? clientWatches.concat(config.clientWatches) : clientWatches, gulp.series("webpack:client"));
        }
        // watch for style changes
        gulp.watch("src/public/**/*.scss", gulp.series("styles", "static:copy", "static:inject"))
            .on("unlink", (a, b) => {
            const cssFilename = path_1.default.basename(a, ".scss") + ".css";
            const cssDirectory = path_1.default.dirname(a).replace("src/public", "./dist");
            const cssPath = path_1.default.join(cssDirectory, cssFilename);
            console.log(cssPath, fs_1.default.existsSync(cssPath));
            if (fs_1.default.existsSync(cssPath)) {
                fs_1.default.unlinkSync(cssPath);
                (0, webTasks_1.injectSources)(gulp, config);
            }
        });
        // watch on new and deleted files
        gulp.watch(config.injectSources ? injectSourceFiles.concat(config.injectSources) : injectSourceFiles)
            .on("unlink", (0, webTasks_1.injectSources)(gulp, config))
            .on("add", (0, webTasks_1.injectSources)(gulp, config));
        // watch for static files
        gulp.watch(config.staticFiles ? staticFilesWatches.concat(config.staticFiles) : staticFilesWatches, gulp.series("static:copy", "static:inject"));
        // watch for .env files
        const envFile = (_a = argv.env) !== null && _a !== void 0 ? _a : ".env";
        (0, fancy_log_1.default)(`Watching ${envFile}`);
        gulp.watch(envFile, gulp.series(reloadEnv, gulp.parallel("manifest", debug ? restartDevServer : "webpack:client"), nodemonRestart));
    };
    gulp.task("watch", registerWatches);
    gulp.task("nodemon", (done) => {
        let started = false;
        (0, nodemon_1.default)({
            script: "dist/server.js",
            watch: ["dist/server.js"],
            nodeArgs: debug ? ["--inspect"] : []
        }).on("start", function () {
            if (!started) {
                done();
                started = true;
                (0, fancy_log_1.default)("PUBLIC_HOSTNAME: " + process.env.PUBLIC_HOSTNAME || process.env.HOSTNAME); // keep HOSTNAME for backwards compatibility
            }
        });
    });
    gulp.task("serve", (0, _1.dependencies)(gulp, "serve", "nuke", "build", "nodemon", "watch"));
};
exports.serveTasks = serveTasks;
