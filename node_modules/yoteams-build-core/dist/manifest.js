"use strict";
// Copyright (c) Wictor WilÃ©n. All rights reserved.
// Licensed under the MIT license.
// SPDX-License-Identifier: MIT
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifest = void 0;
const gulp_token_replace_1 = __importDefault(require("gulp-token-replace"));
const axios_1 = __importDefault(require("axios"));
const plugin_error_1 = __importDefault(require("plugin-error"));
const gulp_filter_1 = __importDefault(require("gulp-filter"));
const through2_1 = __importDefault(require("through2"));
const z_schema_1 = __importDefault(require("z-schema"));
const gulp_rename_1 = __importDefault(require("gulp-rename"));
const schemas_json_1 = __importDefault(require("./schemas.json"));
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const _ = __importStar(require("."));
const gulp_zip_1 = __importDefault(require("gulp-zip"));
const fancy_log_1 = __importDefault(require("fancy-log"));
const flatmap = require("gulp-flatmap");
const argv = require("yargs").argv;
const manifest = (gulp, config) => {
    /**
     * Reads a file and returns JSON
     * @param file the file
     */
    const fileToJson = (file) => {
        if (!file.contents) {
            throw new Error("Invalid file");
        }
        const data = file.contents.toString("utf-8");
        const json = JSON.parse(data);
        return json;
    };
    /**
     * Returns only Teams manifests with a supported version
     */
    const manifestFilter = () => {
        return (0, gulp_filter_1.default)(file => {
            try {
                const json = fileToJson(file);
                const definition = schemas_json_1.default.find((s) => {
                    return s.version === json.manifestVersion;
                });
                if (definition === undefined) {
                    if (argv["schema-validation"] === false) {
                        return true;
                    }
                    (0, fancy_log_1.default)(chalk_1.default.yellow(`Unable to find "${json.manifestVersion}" amongst supported schemas. Use --no-schema-validation to skip validation of schema.`));
                    return false;
                }
                return true;
            }
            catch (err) {
                return false;
            }
        }, { restore: true });
    };
    /**
     * Returns all manifests in the src/manifest folder
     */
    const getManifests = (path) => {
        return gulp.src(path)
            .pipe(manifestFilter());
    };
    /**
     * The manifest generation task - replaces parameters
     */
    const generateManifests = () => {
        return getManifests("src/manifest/*.json")
            .pipe((0, gulp_token_replace_1.default)({
            tokens: Object.assign({}, process.env)
        })).pipe(gulp.dest("./temp"));
    };
    /**
     * validates teams manifest schemas
     */
    function schema() {
        function validate(file, enc, callback) {
            if (!file.contents) {
                throw new Error("Invalid file");
            }
            const data = file.contents.toString("utf-8");
            const json = JSON.parse(data);
            if (argv["schema-validation"] === false) {
                (0, fancy_log_1.default)(chalk_1.default.yellow(`Using unsupported schema "${json.manifestVersion}".`));
                callback(null, file);
                return;
            }
            (0, fancy_log_1.default)(`${file.basename} is using manifest schema ${json.manifestVersion}`);
            const definition = schemas_json_1.default.find((s) => {
                return s.version === json.manifestVersion;
            });
            if (definition === undefined) {
                callback(new plugin_error_1.default("validate-manifest", "Unable to locate schema"));
                return;
            }
            // eslint-disable-next-line dot-notation
            if (json["$schema"] !== definition.schema) {
                (0, fancy_log_1.default)("Note: the defined schema in your manifest does not correspond to the manifestVersion");
            }
            const requiredUrl = definition.schema;
            const validator = new z_schema_1.default({});
            const schema = {
                $ref: requiredUrl
            };
            axios_1.default.get(requiredUrl, {
                headers: {
                    "Accept-Encoding": "none"
                },
                responseType: "json"
            }).then(response => {
                validator.setRemoteReference(requiredUrl, response.data);
                const valid = validator.validate(json, schema);
                const errors = validator.getLastErrors();
                if (!valid) {
                    callback(new plugin_error_1.default("validateSchemas", errors.map((e) => {
                        return `${file.basename}: ${e.message}`;
                    }).join("\n")));
                }
                else {
                    callback(null, file);
                }
            }).catch(err => {
                fancy_log_1.default.warn("WARNING: unable to download and validate schema: " + err);
                callback(null, file);
            });
        }
        return through2_1.default.obj(validate, (callback) => { callback(); });
    }
    ;
    /**
     * The validate schema task
     */
    const validateSchemas = () => {
        return getManifests("temp/*.json")
            .pipe(schema());
    };
    /**
     * Creates an array of all files to include in the packaged manifest
     * @param file the file
     */
    const getPackageFiles = (file) => {
        const arr = [];
        if (!file.contents) {
            throw new Error("Invalid file");
        }
        arr.push(file.path);
        const data = file.contents.toString("utf-8");
        const json = JSON.parse(data);
        // get the icons
        if (json.icons.outline) {
            if (!fs_1.default.existsSync("src/manifest/" + json.icons.outline)) {
                throw new plugin_error_1.default("validate-manifest", `Cannot locate file: ${"src/manifest/" + json.icons.outline}`);
            }
            arr.push("src/manifest/" + json.icons.outline);
            // TODO: check if file exists
        }
        if (json.icons.color) {
            if (!fs_1.default.existsSync("src/manifest/" + json.icons.color)) {
                throw new plugin_error_1.default("validate-manifest", `Cannot locate file: ${"src/manifest/" + json.icons.color}`);
            }
            arr.push("src/manifest/" + json.icons.color);
            // TODO: check if file exists
        }
        if (json.localizationInfo && json.localizationInfo.additionalLanguages) {
            for (const additionalLanguage of json.localizationInfo.additionalLanguages) {
                if (!fs_1.default.existsSync("src/manifest/" + additionalLanguage.file)) {
                    throw new plugin_error_1.default("validate-manifest", `Cannot locate file: ${"src/manifest/" + additionalLanguage.file}`);
                }
                arr.push("src/manifest/" + additionalLanguage.file);
                // TODO: check if file exists
            }
        }
        return arr;
    };
    /**
     * zip together the files and create the package
     */
    const zipTask = (cb) => {
        return getManifests("temp/*.json")
            .pipe(flatmap((stream, file) => {
            if (!file.contents) {
                throw new Error("Invalid file");
            }
            const data = file.contents.toString("utf-8");
            const json = JSON.parse(data);
            const zipName = json.packageName + ".zip";
            (0, fancy_log_1.default)(`Creating package ${zipName}`);
            return gulp.src(getPackageFiles(file))
                .pipe((0, gulp_rename_1.default)((path) => {
                // for some reason rename uses a different definition fo basename
                if (path.basename + path.extname === file.basename) {
                    return Object.assign(Object.assign({}, path), { basename: "manifest" });
                }
                return path;
            }))
                .pipe((0, gulp_zip_1.default)(zipName));
        }))
            .pipe(gulp.dest("package"));
    };
    // export the tasks
    gulp.task("validate-manifest", _.dependencies(gulp, "validate-manifest", generateManifests, validateSchemas));
    gulp.task("manifest", _.dependencies(gulp, "manifest", "validate-manifest", zipTask));
};
exports.manifest = manifest;
