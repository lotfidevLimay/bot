"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pid = void 0;
const os = require("os");
const fs = require("fs");
const child_process_1 = require("child_process");
const cache_1 = require("./cache");
function getProcessNameOnMacOs(pid) {
    const stdout = (0, child_process_1.execSync)(`ps -o comm= ${pid}`, { encoding: 'utf8' });
    return stdout.trim();
}
function getProcessNameOnLinux(pid) {
    if (!fs.existsSync(`/proc/${pid}/stat`)) {
        return undefined;
    }
    const stat = fs.readFileSync(`/proc/${pid}/stat`, 'utf8');
    const start = stat.indexOf('(');
    const procName = stat.substring(start + 1, stat.indexOf(')') - start);
    return procName;
}
function getProcessNameOnWindows(pid) {
    const stdout = (0, child_process_1.execSync)(`wmic PROCESS where ProcessId=${pid} get Caption | find /V "Caption"`, { encoding: 'utf8' });
    return stdout.trim();
}
exports.pid = {
    getProcessName(pid) {
        let processName = cache_1.cache.getValue(pid.toString());
        if (processName) {
            return processName;
        }
        let getPidName = undefined;
        const platform = os.platform();
        if (platform.indexOf('win') === 0) {
            getPidName = getProcessNameOnWindows;
        }
        if (platform === 'darwin') {
            getPidName = getProcessNameOnMacOs;
        }
        if (platform === 'linux') {
            getPidName = getProcessNameOnLinux;
        }
        if (getPidName) {
            try {
                processName = getPidName(pid);
                if (processName) {
                    cache_1.cache.setValue(pid.toString(), processName);
                }
                return processName;
            }
            catch (_a) {
                return undefined;
            }
        }
        return undefined;
    }
};
//# sourceMappingURL=pid.js.map