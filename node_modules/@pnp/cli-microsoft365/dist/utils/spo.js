"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spo = void 0;
const url = require("url");
const urlUtil_1 = require("./urlUtil");
const validation_1 = require("./validation");
const Auth_1 = require("../Auth");
const config_1 = require("../config");
const base_permissions_1 = require("../m365/spo/base-permissions");
const request_1 = require("../request");
exports.spo = {
    getRequestDigest(siteUrl) {
        const requestOptions = {
            url: `${siteUrl}/_api/contextinfo`,
            headers: {
                accept: 'application/json;odata=nometadata'
            },
            responseType: 'json'
        };
        return request_1.default.post(requestOptions);
    },
    ensureFormDigest(siteUrl, logger, context, debug) {
        return new Promise((resolve, reject) => {
            if (validation_1.validation.isValidFormDigest(context)) {
                if (debug) {
                    logger.logToStderr('Existing form digest still valid');
                }
                resolve(context);
                return;
            }
            exports.spo
                .getRequestDigest(siteUrl)
                .then((res) => {
                const now = new Date();
                now.setSeconds(now.getSeconds() + res.FormDigestTimeoutSeconds - 5);
                context = {
                    FormDigestValue: res.FormDigestValue,
                    FormDigestTimeoutSeconds: res.FormDigestTimeoutSeconds,
                    FormDigestExpiresAt: now,
                    WebFullUrl: res.WebFullUrl
                };
                resolve(context);
            }, (error) => {
                reject(error);
            });
        });
    },
    waitUntilFinished({ operationId, siteUrl, resolve, reject, logger, currentContext, dots, debug, verbose }) {
        exports.spo
            .ensureFormDigest(siteUrl, logger, currentContext, debug)
            .then((res) => {
            currentContext = res;
            if (debug) {
                logger.logToStderr(`Checking if operation ${operationId} completed...`);
            }
            if (!debug && verbose) {
                dots += '.';
                process.stdout.write(`\r${dots}`);
            }
            const requestOptions = {
                url: `${siteUrl}/_vti_bin/client.svc/ProcessQuery`,
                headers: {
                    'X-RequestDigest': currentContext.FormDigestValue
                },
                data: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><Query Id="188" ObjectPathId="184"><Query SelectAllProperties="false"><Properties><Property Name="IsComplete" ScalarProperty="true" /><Property Name="PollingInterval" ScalarProperty="true" /></Properties></Query></Query></Actions><ObjectPaths><Identity Id="184" Name="${operationId.replace(/\\n/g, '&#xA;').replace(/"/g, '')}" /></ObjectPaths></Request>`
            };
            return request_1.default.post(requestOptions);
        })
            .then((res) => {
            const json = JSON.parse(res);
            const response = json[0];
            if (response.ErrorInfo) {
                reject(response.ErrorInfo.ErrorMessage);
            }
            else {
                const operation = json[json.length - 1];
                const isComplete = operation.IsComplete;
                if (isComplete) {
                    if (!debug && verbose) {
                        process.stdout.write('\n');
                    }
                    resolve();
                    return;
                }
                setTimeout(() => {
                    exports.spo.waitUntilFinished({
                        operationId: JSON.stringify(operation._ObjectIdentity_),
                        siteUrl,
                        resolve,
                        reject,
                        logger,
                        currentContext,
                        dots,
                        debug,
                        verbose
                    });
                }, operation.PollingInterval);
            }
        });
    },
    waitUntilCopyJobFinished({ copyJobInfo, siteUrl, pollingInterval, resolve, reject, logger, dots, debug, verbose }) {
        const requestUrl = `${siteUrl}/_api/site/GetCopyJobProgress`;
        const requestOptions = {
            url: requestUrl,
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            data: { "copyJobInfo": copyJobInfo },
            responseType: 'json'
        };
        if (!debug && verbose) {
            dots += '.';
            process.stdout.write(`\r${dots}`);
        }
        request_1.default
            .post(requestOptions)
            .then((resp) => {
            if (debug) {
                logger.logToStderr('getCopyJobProgress response...');
                logger.logToStderr(resp);
            }
            for (const item of resp.Logs) {
                const log = JSON.parse(item);
                // reject if progress error
                if (log.Event === "JobError" || log.Event === "JobFatalError") {
                    return reject(log.Message);
                }
            }
            // two possible scenarios
            // job done = success promise returned
            // job in progress = recursive call using setTimeout returned
            if (resp.JobState === 0) {
                // job done
                if (verbose) {
                    process.stdout.write('\n');
                }
                resolve();
            }
            else {
                setTimeout(() => {
                    exports.spo.waitUntilCopyJobFinished({ copyJobInfo, siteUrl, pollingInterval, resolve, reject, logger, dots, debug, verbose });
                }, pollingInterval);
            }
        });
    },
    getSpoUrl(logger, debug) {
        if (Auth_1.default.service.spoUrl) {
            if (debug) {
                logger.logToStderr(`SPO URL previously retrieved ${Auth_1.default.service.spoUrl}. Returning...`);
            }
            return Promise.resolve(Auth_1.default.service.spoUrl);
        }
        return new Promise((resolve, reject) => {
            if (debug) {
                logger.logToStderr(`No SPO URL available. Retrieving from MS Graph...`);
            }
            const requestOptions = {
                url: `https://graph.microsoft.com/v1.0/sites/root?$select=webUrl`,
                headers: {
                    'accept': 'application/json;odata.metadata=none'
                },
                responseType: 'json'
            };
            request_1.default
                .get(requestOptions)
                .then((res) => {
                Auth_1.default.service.spoUrl = res.webUrl;
                return Auth_1.default.storeConnectionInfo();
            })
                .then(() => {
                resolve(Auth_1.default.service.spoUrl);
            }, (err) => {
                if (Auth_1.default.service.spoUrl) {
                    resolve(Auth_1.default.service.spoUrl);
                }
                else {
                    reject(err);
                }
            });
        });
    },
    getSpoAdminUrl(logger, debug) {
        return new Promise((resolve, reject) => {
            exports.spo
                .getSpoUrl(logger, debug)
                .then((spoUrl) => {
                resolve(spoUrl.replace(/(https:\/\/)([^\.]+)(.*)/, '$1$2-admin$3'));
            }, (error) => {
                reject(error);
            });
        });
    },
    getTenantId(logger, debug) {
        if (Auth_1.default.service.tenantId) {
            if (debug) {
                logger.logToStderr(`SPO Tenant ID previously retrieved ${Auth_1.default.service.tenantId}. Returning...`);
            }
            return Promise.resolve(Auth_1.default.service.tenantId);
        }
        return new Promise((resolve, reject) => {
            if (debug) {
                logger.logToStderr(`No SPO Tenant ID available. Retrieving...`);
            }
            let spoAdminUrl = '';
            exports.spo
                .getSpoAdminUrl(logger, debug)
                .then((_spoAdminUrl) => {
                spoAdminUrl = _spoAdminUrl;
                return exports.spo.getRequestDigest(spoAdminUrl);
            })
                .then((contextInfo) => {
                const tenantInfoRequestOptions = {
                    url: `${spoAdminUrl}/_vti_bin/client.svc/ProcessQuery`,
                    headers: {
                        'X-RequestDigest': contextInfo.FormDigestValue,
                        accept: 'application/json;odata=nometadata'
                    },
                    data: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><ObjectPath Id="4" ObjectPathId="3" /><Query Id="5" ObjectPathId="3"><Query SelectAllProperties="true"><Properties /></Query></Query></Actions><ObjectPaths><Constructor Id="3" TypeId="{268004ae-ef6b-4e9b-8425-127220d84719}" /></ObjectPaths></Request>`
                };
                return request_1.default.post(tenantInfoRequestOptions);
            })
                .then((res) => {
                const json = JSON.parse(res);
                Auth_1.default.service.tenantId = json[json.length - 1]._ObjectIdentity_.replace('\n', '&#xA;');
                return Auth_1.default.storeConnectionInfo();
            })
                .then(() => {
                resolve(Auth_1.default.service.tenantId);
            }, (err) => {
                if (Auth_1.default.service.tenantId) {
                    resolve(Auth_1.default.service.tenantId);
                }
                else {
                    reject(err);
                }
            });
        });
    },
    /**
     * Ensures the folder path exists
     * @param webFullUrl web full url e.g. https://contoso.sharepoint.com/sites/site1
     * @param folderToEnsure web relative or server relative folder path e.g. /Documents/MyFolder or /sites/site1/Documents/MyFolder
     * @param siteAccessToken a valid access token for the site specified in the webFullUrl param
     */
    ensureFolder(webFullUrl, folderToEnsure, logger, debug) {
        const webUrl = url.parse(webFullUrl);
        if (!webUrl.protocol || !webUrl.hostname) {
            return Promise.reject('webFullUrl is not a valid URL');
        }
        if (!folderToEnsure) {
            return Promise.reject('folderToEnsure cannot be empty');
        }
        // remove last '/' of webFullUrl if exists
        const webFullUrlLastCharPos = webFullUrl.length - 1;
        if (webFullUrl.length > 1 &&
            webFullUrl[webFullUrlLastCharPos] === '/') {
            webFullUrl = webFullUrl.substring(0, webFullUrlLastCharPos);
        }
        folderToEnsure = urlUtil_1.urlUtil.getWebRelativePath(webFullUrl, folderToEnsure);
        if (debug) {
            logger.log(`folderToEnsure`);
            logger.log(folderToEnsure);
            logger.log('');
        }
        let nextFolder = '';
        let prevFolder = '';
        let folderIndex = 0;
        // build array of folders e.g. ["Shared%20Documents","22","54","55"]
        const folders = folderToEnsure.substring(1).split('/');
        if (debug) {
            logger.log('folders to process');
            logger.log(JSON.stringify(folders));
            logger.log('');
        }
        // recursive function
        const checkOrAddFolder = (resolve, reject) => {
            if (folderIndex === folders.length) {
                if (debug) {
                    logger.log(`All sub-folders exist`);
                }
                return resolve();
            }
            // append the next sub-folder to the folder path and check if it exists
            prevFolder = nextFolder;
            nextFolder += `/${folders[folderIndex]}`;
            const folderServerRelativeUrl = urlUtil_1.urlUtil.getServerRelativePath(webFullUrl, nextFolder);
            const requestOptions = {
                url: `${webFullUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderServerRelativeUrl)}')`,
                headers: {
                    'accept': 'application/json;odata=nometadata'
                }
            };
            request_1.default
                .get(requestOptions)
                .then(() => {
                folderIndex++;
                checkOrAddFolder(resolve, reject);
            })
                .catch(() => {
                const prevFolderServerRelativeUrl = urlUtil_1.urlUtil.getServerRelativePath(webFullUrl, prevFolder);
                const requestOptions = {
                    url: `${webFullUrl}/_api/web/GetFolderByServerRelativePath(DecodedUrl=@a1)/AddSubFolderUsingPath(DecodedUrl=@a2)?@a1=%27${encodeURIComponent(prevFolderServerRelativeUrl)}%27&@a2=%27${encodeURIComponent(folders[folderIndex])}%27`,
                    headers: {
                        'accept': 'application/json;odata=nometadata'
                    },
                    responseType: 'json'
                };
                return request_1.default.post(requestOptions)
                    .then(() => {
                    folderIndex++;
                    checkOrAddFolder(resolve, reject);
                })
                    .catch((err) => {
                    if (debug) {
                        logger.log(`Could not create sub-folder ${folderServerRelativeUrl}`);
                    }
                    reject(err);
                });
            });
        };
        return new Promise(checkOrAddFolder);
    },
    /**
     * Requests web object identity for the current web.
     * That request is something similar to _contextinfo in REST.
     * The response data looks like:
     * _ObjectIdentity_=<GUID>|<GUID>:site:<GUID>:web:<GUID>
     * _ObjectType_=SP.Web
     * ServerRelativeUrl=/sites/contoso
     * @param webUrl web url
     * @param formDigestValue formDigestValue
     */
    getCurrentWebIdentity(webUrl, formDigestValue) {
        const requestOptions = {
            url: `${webUrl}/_vti_bin/client.svc/ProcessQuery`,
            headers: {
                'X-RequestDigest': formDigestValue
            },
            data: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><Query Id="1" ObjectPathId="5"><Query SelectAllProperties="false"><Properties><Property Name="ServerRelativeUrl" ScalarProperty="true" /></Properties></Query></Query></Actions><ObjectPaths><Property Id="5" ParentId="3" Name="Web" /><StaticProperty Id="3" TypeId="{3747adcd-a3c3-41b9-bfab-4a64dd2f1e0a}" Name="Current" /></ObjectPaths></Request>`
        };
        return new Promise((resolve, reject) => {
            request_1.default.post(requestOptions).then((res) => {
                const json = JSON.parse(res);
                const contents = json.find(x => { return x.ErrorInfo; });
                if (contents && contents.ErrorInfo) {
                    return reject(contents.ErrorInfo.ErrorMessage || 'ClientSvc unknown error');
                }
                const identityObject = json.find(x => { return x._ObjectIdentity_; });
                if (identityObject) {
                    return resolve({
                        objectIdentity: identityObject._ObjectIdentity_,
                        serverRelativeUrl: identityObject.ServerRelativeUrl
                    });
                }
                reject('Cannot proceed. _ObjectIdentity_ not found'); // this is not supposed to happen
            }, (err) => { reject(err); });
        });
    },
    /**
     * Gets EffectiveBasePermissions for web return type is "_ObjectType_\":\"SP.Web\".
     * @param webObjectIdentity ObjectIdentity. Has format _ObjectIdentity_=<GUID>|<GUID>:site:<GUID>:web:<GUID>
     * @param webUrl web url
     * @param siteAccessToken site access token
     * @param formDigestValue formDigestValue
     */
    getEffectiveBasePermissions(webObjectIdentity, webUrl, formDigestValue, logger, debug) {
        const basePermissionsResult = new base_permissions_1.BasePermissions();
        const requestOptions = {
            url: `${webUrl}/_vti_bin/client.svc/ProcessQuery`,
            headers: {
                'X-RequestDigest': formDigestValue
            },
            data: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><Query Id="11" ObjectPathId="5"><Query SelectAllProperties="false"><Properties><Property Name="EffectiveBasePermissions" ScalarProperty="true" /></Properties></Query></Query></Actions><ObjectPaths><Identity Id="5" Name="${webObjectIdentity}" /></ObjectPaths></Request>`
        };
        return new Promise((resolve, reject) => {
            request_1.default.post(requestOptions).then((res) => {
                if (debug) {
                    logger.log('Attempt to get the web EffectiveBasePermissions');
                }
                const json = JSON.parse(res);
                const contents = json.find(x => { return x.ErrorInfo; });
                if (contents && contents.ErrorInfo) {
                    return reject(contents.ErrorInfo.ErrorMessage || 'ClientSvc unknown error');
                }
                const permissionsObj = json.find(x => { return x.EffectiveBasePermissions; });
                if (permissionsObj) {
                    basePermissionsResult.high = permissionsObj.EffectiveBasePermissions.High;
                    basePermissionsResult.low = permissionsObj.EffectiveBasePermissions.Low;
                    return resolve(basePermissionsResult);
                }
                reject('Cannot proceed. EffectiveBasePermissions not found'); // this is not supposed to happen
            }, (err) => { reject(err); });
        });
    },
    /**
      * Gets folder by server relative url (GetFolderByServerRelativeUrl in REST)
      * The response data looks like:
      * _ObjectIdentity_=<GUID>|<GUID>:site:<GUID>:web:<GUID>:folder:<GUID>
      * _ObjectType_=SP.Folder
      * @param webObjectIdentity ObjectIdentity. Has format _ObjectIdentity_=<GUID>|<GUID>:site:<GUID>:web:<GUID>
      * @param webUrl web url
      * @param siteRelativeUrl site relative url e.g. /Shared Documents/Folder1
      * @param formDigestValue formDigestValue
      */
    getFolderIdentity(webObjectIdentity, webUrl, siteRelativeUrl, formDigestValue) {
        const serverRelativePath = urlUtil_1.urlUtil.getServerRelativePath(webUrl, siteRelativeUrl);
        const requestOptions = {
            url: `${webUrl}/_vti_bin/client.svc/ProcessQuery`,
            headers: {
                'X-RequestDigest': formDigestValue
            },
            data: `<Request AddExpandoFieldTypeSuffix="true" SchemaVersion="15.0.0.0" LibraryVersion="16.0.0.0" ApplicationName="${config_1.default.applicationName}" xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"><Actions><ObjectPath Id="10" ObjectPathId="9" /><ObjectIdentityQuery Id="11" ObjectPathId="9" /><Query Id="12" ObjectPathId="9"><Query SelectAllProperties="false"><Properties><Property Name="Properties" SelectAll="true"><Query SelectAllProperties="false"><Properties /></Query></Property></Properties></Query></Query></Actions><ObjectPaths><Method Id="9" ParentId="5" Name="GetFolderByServerRelativeUrl"><Parameters><Parameter Type="String">${serverRelativePath}</Parameter></Parameters></Method><Identity Id="5" Name="${webObjectIdentity}" /></ObjectPaths></Request>`
        };
        return new Promise((resolve, reject) => {
            return request_1.default.post(requestOptions).then((res) => {
                const json = JSON.parse(res);
                const contents = json.find(x => { return x.ErrorInfo; });
                if (contents && contents.ErrorInfo) {
                    return reject(contents.ErrorInfo.ErrorMessage || 'ClientSvc unknown error');
                }
                const objectIdentity = json.find(x => { return x._ObjectIdentity_; });
                if (objectIdentity) {
                    return resolve({
                        objectIdentity: objectIdentity._ObjectIdentity_,
                        serverRelativeUrl: serverRelativePath
                    });
                }
                reject('Cannot proceed. Folder _ObjectIdentity_ not found'); // this is not suppose to happen
            }, (err) => { reject(err); });
        });
    }
};
//# sourceMappingURL=spo.js.map