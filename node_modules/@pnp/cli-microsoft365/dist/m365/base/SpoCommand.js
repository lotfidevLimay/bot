"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Auth_1 = require("../../Auth");
const Command_1 = require("../../Command");
const csomDefs = require('../../../csom.json');
class SpoCommand extends Command_1.default {
    /**
     * Defines list of options that contain URLs in spo commands. CLI will use
     * this list to expand server-relative URLs specified in these options to
     * absolute.
     * If a command requires one of these options to contain a server-relative
     * URL, it should override this method and remove the necessary property from
     * the array before returning it.
     */
    getNamesOfOptionsWithUrls() {
        const namesOfOptionsWithUrls = [
            'appCatalogUrl',
            'siteUrl',
            'webUrl',
            'origin',
            'url',
            'imageUrl',
            'actionUrl',
            'logoUrl',
            'libraryUrl',
            'thumbnailUrl',
            'targetUrl',
            'newSiteUrl',
            'previewImageUrl',
            'NoAccessRedirectUrl',
            'StartASiteFormUrl',
            'OrgNewsSiteUrl',
            'parentWebUrl',
            'siteLogoUrl'
        ];
        const excludedOptionsWithUrls = this.getExcludedOptionsWithUrls();
        if (!excludedOptionsWithUrls) {
            return namesOfOptionsWithUrls;
        }
        else {
            return namesOfOptionsWithUrls.filter(o => excludedOptionsWithUrls.indexOf(o) < 0);
        }
    }
    /**
     * Array of names of options with URLs that should be excluded
     * from processing. To be overriden in commands that require
     * specific options to be a server-relative URL
     */
    getExcludedOptionsWithUrls() {
        return undefined;
    }
    processOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const namesOfOptionsWithUrls = this.getNamesOfOptionsWithUrls();
            const optionNames = Object.getOwnPropertyNames(options);
            for (const optionName of optionNames) {
                if (namesOfOptionsWithUrls.indexOf(optionName) < 0) {
                    continue;
                }
                const optionValue = options[optionName];
                if (typeof optionValue !== 'string' ||
                    !optionValue.startsWith('/')) {
                    continue;
                }
                yield Auth_1.default.restoreAuth();
                if (!Auth_1.default.service.spoUrl) {
                    throw new Error(`SharePoint URL is not available. Set SharePoint URL using the 'm365 spo set' command or use absolute URLs`);
                }
                options[optionName] = Auth_1.default.service.spoUrl + optionValue;
            }
        });
    }
    validateUnknownCsomOptions(options, csomObject, csomPropertyType) {
        const unknownOptions = this.getUnknownOptions(options);
        const optionNames = Object.getOwnPropertyNames(unknownOptions);
        if (optionNames.length === 0) {
            return true;
        }
        for (let i = 0; i < optionNames.length; i++) {
            const optionName = optionNames[i];
            const csomOptionType = csomDefs[csomObject][csomPropertyType][optionName];
            if (!csomOptionType) {
                return `${optionName} is not a valid ${csomObject} property`;
            }
            if (['Boolean', 'String', 'Int32'].indexOf(csomOptionType) < 0) {
                return `Unknown properties of type ${csomOptionType} are not yet supported`;
            }
        }
        return true;
    }
    action(logger, args) {
        const _super = Object.create(null, {
            action: { get: () => super.action }
        });
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield Auth_1.default.restoreAuth();
            }
            catch (error) {
                throw new Command_1.CommandError(error);
            }
            if (Auth_1.default.service.connected && Auth_1.AuthType[Auth_1.default.service.authType] === Auth_1.AuthType[Auth_1.AuthType.Secret]) {
                throw new Command_1.CommandError(`SharePoint does not support authentication using client ID and secret. Please use a different login type to use SharePoint commands.`);
            }
            yield _super.action.call(this, logger, args);
        });
    }
}
exports.default = SpoCommand;
//# sourceMappingURL=SpoCommand.js.map