"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AadPolicyListCommand_instances, _AadPolicyListCommand_initTelemetry, _AadPolicyListCommand_initOptions, _AadPolicyListCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = require("../../../../request");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
const policyEndPoints = {
    activitybasedtimeout: "activityBasedTimeoutPolicies",
    authorization: "authorizationPolicy",
    claimsmapping: "claimsMappingPolicies",
    homerealmdiscovery: "homeRealmDiscoveryPolicies",
    identitysecuritydefaultsenforcement: "identitySecurityDefaultsEnforcementPolicy",
    tokenissuance: "tokenIssuancePolicies",
    tokenlifetime: "tokenLifetimePolicies"
};
class AadPolicyListCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _AadPolicyListCommand_instances.add(this);
        __classPrivateFieldGet(this, _AadPolicyListCommand_instances, "m", _AadPolicyListCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _AadPolicyListCommand_instances, "m", _AadPolicyListCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _AadPolicyListCommand_instances, "m", _AadPolicyListCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.POLICY_LIST;
    }
    get description() {
        return 'Returns policies from Azure AD';
    }
    defaultProperties() {
        return ['id', 'displayName', 'isOrganizationDefault'];
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const policyType = args.options.policyType ? args.options.policyType.toLowerCase() : 'all';
            try {
                if (policyType && policyType !== "all") {
                    const policies = yield this.getPolicies(policyType);
                    logger.log(policies);
                }
                else {
                    const policyTypes = Object.keys(policyEndPoints);
                    const results = yield Promise.all(policyTypes.map(policyType => this.getPolicies(policyType)));
                    let allPolicies = [];
                    results.forEach((policies) => {
                        allPolicies = allPolicies.concat(policies);
                    });
                    logger.log(allPolicies);
                }
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getPolicies(policyType) {
        const endpoint = policyEndPoints[policyType];
        const requestOptions = {
            url: `${this.resource}/v1.0/policies/${endpoint}`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default
            .get(requestOptions)
            .then((response) => {
            if (endpoint === policyEndPoints.authorization ||
                endpoint === policyEndPoints.identitysecuritydefaultsenforcement) {
                return Promise.resolve(response);
            }
            else {
                return Promise.resolve(response.value);
            }
        });
    }
}
_AadPolicyListCommand_instances = new WeakSet(), _AadPolicyListCommand_initTelemetry = function _AadPolicyListCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            policyType: args.options.policyType || 'all'
        });
    });
}, _AadPolicyListCommand_initOptions = function _AadPolicyListCommand_initOptions() {
    this.options.unshift({
        option: '-p, --policyType [policyType]',
        autocomplete: AadPolicyListCommand.supportedPolicyTypes
    });
}, _AadPolicyListCommand_initValidators = function _AadPolicyListCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.policyType) {
            const policyType = args.options.policyType.toLowerCase();
            if (!AadPolicyListCommand.supportedPolicyTypes.find(p => p.toLowerCase() === policyType)) {
                return `${args.options.policyType} is not a valid policyType. Allowed values are ${AadPolicyListCommand.supportedPolicyTypes.join(', ')}`;
            }
        }
        return true;
    }));
};
AadPolicyListCommand.supportedPolicyTypes = ['activityBasedTimeout', 'authorization', 'claimsMapping', 'homeRealmDiscovery', 'identitySecurityDefaultsEnforcement', 'tokenIssuance', 'tokenLifetime'];
module.exports = new AadPolicyListCommand();
//# sourceMappingURL=policy-list.js.map