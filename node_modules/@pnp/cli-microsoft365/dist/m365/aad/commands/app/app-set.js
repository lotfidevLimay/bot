"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AadAppSetCommand_instances, _AadAppSetCommand_initTelemetry, _AadAppSetCommand_initOptions, _AadAppSetCommand_initValidators, _AadAppSetCommand_initOptionSets;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const request_1 = require("../../../../request");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
class AadAppSetCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _AadAppSetCommand_instances.add(this);
        __classPrivateFieldGet(this, _AadAppSetCommand_instances, "m", _AadAppSetCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _AadAppSetCommand_instances, "m", _AadAppSetCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _AadAppSetCommand_instances, "m", _AadAppSetCommand_initValidators).call(this);
        __classPrivateFieldGet(this, _AadAppSetCommand_instances, "m", _AadAppSetCommand_initOptionSets).call(this);
    }
    get name() {
        return commands_1.default.APP_SET;
    }
    get description() {
        return 'Updates Azure AD app registration';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let objectId = yield this.getAppObjectId(args, logger);
                objectId = yield this.configureUri(args, objectId, logger);
                objectId = yield this.configureRedirectUris(args, objectId, logger);
                yield this.configureCertificate(args, objectId, logger);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getAppObjectId(args, logger) {
        if (args.options.objectId) {
            return Promise.resolve(args.options.objectId);
        }
        const { appId, name } = args.options;
        if (this.verbose) {
            logger.logToStderr(`Retrieving information about Azure AD app ${appId ? appId : name}...`);
        }
        const filter = appId ?
            `appId eq '${encodeURIComponent(appId)}'` :
            `displayName eq '${encodeURIComponent(name)}'`;
        const requestOptions = {
            url: `${this.resource}/v1.0/myorganization/applications?$filter=${filter}&$select=id`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default
            .get(requestOptions)
            .then((res) => {
            if (res.value.length === 1) {
                return Promise.resolve(res.value[0].id);
            }
            if (res.value.length === 0) {
                const applicationIdentifier = appId ? `ID ${appId}` : `name ${name}`;
                return Promise.reject(`No Azure AD application registration with ${applicationIdentifier} found`);
            }
            return Promise.reject(`Multiple Azure AD application registration with name ${name} found. Please disambiguate (app object IDs): ${res.value.map(a => a.id).join(', ')}`);
        });
    }
    configureUri(args, objectId, logger) {
        if (!args.options.uri) {
            return Promise.resolve(objectId);
        }
        if (this.verbose) {
            logger.logToStderr(`Configuring Azure AD application ID URI...`);
        }
        const identifierUris = args.options.uri
            .split(',')
            .map(u => u.trim());
        const applicationInfo = {
            identifierUris: identifierUris
        };
        const requestOptions = {
            url: `${this.resource}/v1.0/myorganization/applications/${objectId}`,
            headers: {
                'content-type': 'application/json;odata.metadata=none'
            },
            responseType: 'json',
            data: applicationInfo
        };
        return request_1.default
            .patch(requestOptions)
            .then(_ => Promise.resolve(objectId));
    }
    configureRedirectUris(args, objectId, logger) {
        if (!args.options.redirectUris && !args.options.redirectUrisToRemove) {
            return Promise.resolve(objectId);
        }
        if (this.verbose) {
            logger.logToStderr(`Configuring Azure AD application redirect URIs...`);
        }
        const getAppRequestOptions = {
            url: `${this.resource}/v1.0/myorganization/applications/${objectId}`,
            headers: {
                'content-type': 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default
            .get(getAppRequestOptions)
            .then((application) => {
            const publicClientRedirectUris = application.publicClient.redirectUris;
            const spaRedirectUris = application.spa.redirectUris;
            const webRedirectUris = application.web.redirectUris;
            // start with existing redirect URIs
            const applicationPatch = {
                publicClient: {
                    redirectUris: publicClientRedirectUris
                },
                spa: {
                    redirectUris: spaRedirectUris
                },
                web: {
                    redirectUris: webRedirectUris
                }
            };
            if (args.options.redirectUrisToRemove) {
                // remove redirect URIs from all platforms
                const redirectUrisToRemove = args.options.redirectUrisToRemove
                    .split(',')
                    .map(u => u.trim());
                applicationPatch.publicClient.redirectUris =
                    publicClientRedirectUris.filter(u => !redirectUrisToRemove.includes(u));
                applicationPatch.spa.redirectUris =
                    spaRedirectUris.filter(u => !redirectUrisToRemove.includes(u));
                applicationPatch.web.redirectUris =
                    webRedirectUris.filter(u => !redirectUrisToRemove.includes(u));
            }
            if (args.options.redirectUris) {
                const urlsToAdd = args.options.redirectUris
                    .split(',')
                    .map(u => u.trim());
                // add new redirect URIs. If the URI is already present, it will be ignored
                switch (args.options.platform) {
                    case 'spa':
                        applicationPatch.spa.redirectUris
                            .push(...urlsToAdd.filter(u => !spaRedirectUris.includes(u)));
                        break;
                    case 'publicClient':
                        applicationPatch.publicClient.redirectUris
                            .push(...urlsToAdd.filter(u => !publicClientRedirectUris.includes(u)));
                        break;
                    case 'web':
                        applicationPatch.web.redirectUris
                            .push(...urlsToAdd.filter(u => !webRedirectUris.includes(u)));
                }
            }
            const requestOptions = {
                url: `${this.resource}/v1.0/myorganization/applications/${objectId}`,
                headers: {
                    'content-type': 'application/json;odata.metadata=none'
                },
                responseType: 'json',
                data: applicationPatch
            };
            return request_1.default.patch(requestOptions);
        })
            .then(_ => Promise.resolve(objectId));
    }
    configureCertificate(args, objectId, logger) {
        if (!args.options.certificateFile && !args.options.certificateBase64Encoded) {
            return Promise.resolve();
        }
        if (this.verbose) {
            logger.logToStderr(`Setting certificate for Azure AD app...`);
        }
        const certificateBase64Encoded = this.getCertificateBase64Encoded(args, logger);
        return this
            .getCurrentKeyCredentialsList(args, objectId, certificateBase64Encoded, logger)
            .then(currentKeyCredentials => {
            if (this.verbose) {
                logger.logToStderr(`Adding new keyCredential to list`);
            }
            // The KeyCredential graph type defines the 'key' property as 'NullableOption<number>'
            // while it is a base64 encoded string. This is why a cast to any is used here.
            const keyCredentials = currentKeyCredentials.filter(existingCredential => existingCredential.key !== certificateBase64Encoded);
            const newKeyCredential = {
                type: "AsymmetricX509Cert",
                usage: "Verify",
                displayName: args.options.certificateDisplayName,
                key: certificateBase64Encoded
            };
            keyCredentials.push(newKeyCredential);
            return Promise.resolve(keyCredentials);
        })
            .then(keyCredentials => this.updateKeyCredentials(objectId, keyCredentials, logger));
    }
    getCertificateBase64Encoded(args, logger) {
        if (args.options.certificateBase64Encoded) {
            return args.options.certificateBase64Encoded;
        }
        if (this.debug) {
            logger.logToStderr(`Reading existing ${args.options.certificateFile}...`);
        }
        try {
            return fs.readFileSync(args.options.certificateFile, { encoding: 'base64' });
        }
        catch (e) {
            throw new Error(`Error reading certificate file: ${e}. Please add the certificate using base64 option '--certificateBase64Encoded'.`);
        }
    }
    // We first retrieve existing certificates because we need to specify the full list of certificates when updating the app.
    getCurrentKeyCredentialsList(args, objectId, certificateBase64Encoded, logger) {
        if (this.verbose) {
            logger.logToStderr(`Retrieving current keyCredentials list for app`);
        }
        const getAppRequestOptions = {
            url: `${this.resource}/v1.0/myorganization/applications/${objectId}?$select=keyCredentials`,
            headers: {
                'content-type': 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default.get(getAppRequestOptions).then((application) => {
            return Promise.resolve(application.keyCredentials || []);
        });
    }
    updateKeyCredentials(objectId, keyCredentials, logger) {
        if (this.verbose) {
            logger.logToStderr(`Updating keyCredentials in AAD app`);
        }
        const requestOptions = {
            url: `${this.resource}/v1.0/myorganization/applications/${objectId}`,
            headers: {
                'content-type': 'application/json;odata.metadata=none'
            },
            responseType: 'json',
            data: {
                keyCredentials: keyCredentials
            }
        };
        return request_1.default.patch(requestOptions);
    }
}
_AadAppSetCommand_instances = new WeakSet(), _AadAppSetCommand_initTelemetry = function _AadAppSetCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            appId: typeof args.options.appId !== 'undefined',
            objectId: typeof args.options.objectId !== 'undefined',
            name: typeof args.options.name !== 'undefined',
            platform: typeof args.options.platform !== 'undefined',
            redirectUris: typeof args.options.redirectUris !== 'undefined',
            redirectUrisToRemove: typeof args.options.redirectUrisToRemove !== 'undefined',
            uri: typeof args.options.uri !== 'undefined',
            certificateFile: typeof args.options.certificateFile !== 'undefined',
            certificateBase64Encoded: typeof args.options.certificateBase64Encoded !== 'undefined',
            certificateDisplayName: typeof args.options.certificateDisplayName !== 'undefined'
        });
    });
}, _AadAppSetCommand_initOptions = function _AadAppSetCommand_initOptions() {
    this.options.unshift({ option: '--appId [appId]' }, { option: '--objectId [objectId]' }, { option: '-n, --name [name]' }, { option: '-u, --uri [uri]' }, { option: '-r, --redirectUris [redirectUris]' }, { option: '--certificateFile [certificateFile]' }, { option: '--certificateBase64Encoded [certificateBase64Encoded]' }, { option: '--certificateDisplayName [certificateDisplayName]' }, {
        option: '--platform [platform]',
        autocomplete: AadAppSetCommand.aadApplicationPlatform
    }, { option: '--redirectUrisToRemove [redirectUrisToRemove]' });
}, _AadAppSetCommand_initValidators = function _AadAppSetCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.certificateFile && args.options.certificateBase64Encoded) {
            return 'Specify either certificateFile or certificateBase64Encoded but not both';
        }
        if (args.options.certificateDisplayName && !args.options.certificateFile && !args.options.certificateBase64Encoded) {
            return 'When you specify certificateDisplayName you also need to specify certificateFile or certificateBase64Encoded';
        }
        if (args.options.certificateFile && !fs.existsSync(args.options.certificateFile)) {
            return 'Certificate file not found';
        }
        if (args.options.redirectUris && !args.options.platform) {
            return `When you specify redirectUris you also need to specify platform`;
        }
        if (args.options.platform &&
            AadAppSetCommand.aadApplicationPlatform.indexOf(args.options.platform) < 0) {
            return `${args.options.platform} is not a valid value for platform. Allowed values are ${AadAppSetCommand.aadApplicationPlatform.join(', ')}`;
        }
        return true;
    }));
}, _AadAppSetCommand_initOptionSets = function _AadAppSetCommand_initOptionSets() {
    this.optionSets.push(['appId', 'objectId', 'name']);
};
AadAppSetCommand.aadApplicationPlatform = ['spa', 'web', 'publicClient'];
module.exports = new AadAppSetCommand();
//# sourceMappingURL=app-set.js.map