"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const Auth_1 = require("../../../Auth");
const Cli_1 = require("../../../cli/Cli");
const Command_1 = require("../../../Command");
const validation_1 = require("../../../utils/validation");
const commands_1 = require("../commands");
const packageJSON = require('../../../../package.json');
class CliDoctorCommand extends Command_1.default {
    get name() {
        return commands_1.default.DOCTOR;
    }
    get description() {
        return 'Retrieves diagnostic information about the current environment';
    }
    commandAction(logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const roles = [];
            const scopes = [];
            Object.keys(Auth_1.default.service.accessTokens).forEach(resource => {
                const accessToken = Auth_1.default.service.accessTokens[resource].accessToken;
                this.getRolesFromAccessToken(accessToken).forEach(role => roles.push(role));
                this.getScopesFromAccessToken(accessToken).forEach(scope => scopes.push(scope));
            });
            const diagnosticInfo = {
                os: {
                    platform: os.platform(),
                    version: os.version(),
                    release: os.release()
                },
                cliVersion: packageJSON.version,
                nodeVersion: process.version,
                cliAadAppId: Auth_1.default.service.appId,
                cliAadAppTenant: validation_1.validation.isValidGuid(Auth_1.default.service.tenant) ? 'single' : Auth_1.default.service.tenant,
                authMode: Auth_1.AuthType[Auth_1.default.service.authType],
                cliEnvironment: process.env.CLIMICROSOFT365_ENV ? process.env.CLIMICROSOFT365_ENV : '',
                cliConfig: Cli_1.Cli.getInstance().config.all,
                roles: roles,
                scopes: scopes
            };
            logger.log(diagnosticInfo);
        });
    }
    getRolesFromAccessToken(accessToken) {
        let roles = [];
        if (!accessToken || accessToken.length === 0) {
            return roles;
        }
        const chunks = accessToken.split('.');
        if (chunks.length !== 3) {
            return roles;
        }
        const tokenString = Buffer.from(chunks[1], 'base64').toString();
        const token = JSON.parse(tokenString);
        if (token.roles !== undefined) {
            roles = token.roles;
        }
        return roles;
    }
    getScopesFromAccessToken(accessToken) {
        var _a;
        let scopes = [];
        if (!accessToken || accessToken.length === 0) {
            return scopes;
        }
        const chunks = accessToken.split('.');
        if (chunks.length !== 3) {
            return scopes;
        }
        const tokenString = Buffer.from(chunks[1], 'base64').toString();
        const token = JSON.parse(tokenString);
        if (((_a = token.scp) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            scopes = token.scp.split(' ');
        }
        return scopes;
    }
}
module.exports = new CliDoctorCommand();
//# sourceMappingURL=cli-doctor.js.map