"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RequestCommand_instances, _RequestCommand_initTelemetry, _RequestCommand_initOptions, _RequestCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const Command_1 = require("../../Command");
const request_1 = require("../../request");
const commands_1 = require("./commands");
const path = require("path");
class RequestCommand extends Command_1.default {
    constructor() {
        super();
        _RequestCommand_instances.add(this);
        this.allowedMethods = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options'];
        __classPrivateFieldGet(this, _RequestCommand_instances, "m", _RequestCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _RequestCommand_instances, "m", _RequestCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _RequestCommand_instances, "m", _RequestCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.REQUEST;
    }
    get description() {
        return 'Executes the specified web request using CLI for Microsoft 365';
    }
    allowUnknownOptions() {
        return true;
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug) {
                logger.logToStderr(`Preparing request...`);
            }
            try {
                const method = (args.options.method || 'get').toUpperCase();
                const headers = {};
                const unknownOptions = this.getUnknownOptions(args.options);
                const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
                unknownOptionsNames.forEach(o => {
                    headers[o] = unknownOptions[o];
                });
                if (!headers.accept) {
                    headers.accept = 'application/json';
                }
                if (args.options.resource) {
                    headers['x-resource'] = args.options.resource;
                }
                const config = {
                    url: args.options.url,
                    headers,
                    method,
                    data: args.options.body
                };
                if (headers.accept.toString().startsWith('application/json')) {
                    config.responseType = 'json';
                }
                if (args.options.filePath) {
                    config.responseType = 'stream';
                }
                if (this.verbose) {
                    logger.logToStderr(`Executing request...`);
                }
                if (args.options.filePath) {
                    const file = yield request_1.default.execute(config);
                    const filePath = yield new Promise((resolve, reject) => {
                        const writer = fs.createWriteStream(args.options.filePath);
                        file.data.pipe(writer);
                        writer.on('error', err => {
                            reject(err);
                        });
                        writer.on('close', () => {
                            resolve(args.options.filePath);
                        });
                    });
                    if (this.verbose) {
                        logger.logToStderr(`File saved to path ${filePath}`);
                    }
                }
                else {
                    const res = yield request_1.default.execute(config);
                    logger.log(res);
                }
            }
            catch (err) {
                this.handleError(err);
            }
        });
    }
}
_RequestCommand_instances = new WeakSet(), _RequestCommand_initTelemetry = function _RequestCommand_initTelemetry() {
    this.telemetry.push((args) => {
        const properties = {
            method: args.options.method || 'get',
            resource: typeof args.options.resource !== 'undefined',
            accept: args.options.accept || 'application/json',
            body: typeof args.options.body !== 'undefined',
            filePath: typeof args.options.filePath !== 'undefined'
        };
        const unknownOptions = this.getUnknownOptions(args.options);
        const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
        unknownOptionsNames.forEach(o => {
            properties[o] = typeof unknownOptions[o] !== 'undefined';
        });
        Object.assign(this.telemetryProperties, properties);
    });
}, _RequestCommand_initOptions = function _RequestCommand_initOptions() {
    this.options.unshift({
        option: '-u, --url <url>'
    }, {
        option: '-m, --method [method]',
        autocomplete: this.allowedMethods
    }, {
        option: '-r, --resource [resource]'
    }, {
        option: '-b, --body [body]'
    }, {
        option: '-p, --filePath [filePath]'
    });
}, _RequestCommand_initValidators = function _RequestCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        const currentMethod = args.options.method || 'get';
        if (this.allowedMethods.indexOf(currentMethod) === -1) {
            return `${currentMethod} is not a valid value for method. Allowed values: ${this.allowedMethods.join(', ')}`;
        }
        if (args.options.body && (!args.options.method || args.options.method === 'get')) {
            return 'Specify a different method when using body';
        }
        if (args.options.body && !args.options['content-type']) {
            return 'Specify the content-type when using body';
        }
        if (args.options.filePath && !fs.existsSync(path.dirname(args.options.filePath))) {
            return 'The location specified in the filePath does not exist';
        }
        return true;
    }));
};
module.exports = new RequestCommand();
//# sourceMappingURL=request.js.map