"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _VivaConnectionsAppCreateCommand_instances, _VivaConnectionsAppCreateCommand_initOptions, _VivaConnectionsAppCreateCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const AdmZip = require("adm-zip");
const fs = require("fs");
const path = require("path");
const uuid_1 = require("uuid");
const Cli_1 = require("../../../../cli/Cli");
const AnonymousCommand_1 = require("../../../base/AnonymousCommand");
const spoWebGetCommand = require("../../../spo/commands/web/web-get");
const commands_1 = require("../../commands");
class VivaConnectionsAppCreateCommand extends AnonymousCommand_1.default {
    constructor() {
        super();
        _VivaConnectionsAppCreateCommand_instances.add(this);
        __classPrivateFieldGet(this, _VivaConnectionsAppCreateCommand_instances, "m", _VivaConnectionsAppCreateCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _VivaConnectionsAppCreateCommand_instances, "m", _VivaConnectionsAppCreateCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.CONNECTIONS_APP_CREATE;
    }
    get description() {
        return 'Creates Viva Connections app';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const getWebOutput = yield this.getWeb(args, logger);
                if (this.debug) {
                    logger.logToStderr(getWebOutput.stderr);
                }
                if (this.verbose) {
                    logger.logToStderr(`Site found at ${args.options.portalUrl}. Checking if it's a communication site...`);
                }
                const web = JSON.parse(getWebOutput.stdout);
                if (web.WebTemplate !== 'SITEPAGEPUBLISHING' ||
                    web.Configuration !== 0) {
                    throw `Site ${args.options.portalUrl} is not a Communication Site. Please specify a different site and try again.`;
                }
                if (this.verbose) {
                    logger.logToStderr(`Site ${args.options.portalUrl} is a Communication Site. Building app...`);
                }
                const portalUrl = new URL(args.options.portalUrl);
                const appPortalUrl = `${args.options.portalUrl}${args.options.portalUrl.indexOf('?') > -1 ? '&' : '?'}app=portals`;
                let searchUrlPath = portalUrl.hostname;
                if (portalUrl.pathname.indexOf('/teams') > -1 || portalUrl.pathname.indexOf('/sites') > -1) {
                    const firstTwoUrlSegments = portalUrl.pathname.match(/^\/[^\/]+\/[^\/]+/);
                    if (firstTwoUrlSegments) {
                        searchUrlPath += firstTwoUrlSegments[0];
                    }
                }
                const coloredIconPath = path.resolve(args.options.coloredIconPath);
                const coloredIconFileName = path.basename(coloredIconPath);
                const outlineIconPath = path.resolve(args.options.outlineIconPath);
                const outlineIconFileName = path.basename(outlineIconPath);
                const domain = portalUrl.hostname;
                const appId = (0, uuid_1.v4)();
                const manifest = {
                    "$schema": "https://developer.microsoft.com/en-us/json-schemas/teams/v1.9/MicrosoftTeams.schema.json",
                    "manifestVersion": "1.9",
                    "version": "1.0",
                    "id": appId,
                    "packageName": `com.microsoft.teams.${args.options.appName}`,
                    "developer": {
                        "name": args.options.companyName,
                        "websiteUrl": args.options.companyWebsiteUrl,
                        "privacyUrl": args.options.privacyPolicyUrl || 'https://privacy.microsoft.com/en-us/privacystatement',
                        "termsOfUseUrl": args.options.termsOfUseUrl || 'https://go.microsoft.com/fwlink/?linkid=2039674'
                    },
                    "icons": {
                        "color": coloredIconFileName,
                        "outline": outlineIconFileName
                    },
                    "name": {
                        "short": args.options.appName,
                        "full": args.options.appName
                    },
                    "description": {
                        "short": `${args.options.description}`,
                        "full": `${args.options.longDescription}`
                    },
                    "accentColor": args.options.accentColor || '#40497E',
                    "isFullScreen": true,
                    "staticTabs": [
                        {
                            "entityId": `sharepointportal_${appId}`,
                            "name": `Portals-${args.options.appName}`,
                            "contentUrl": `https://${domain}/_layouts/15/teamslogon.aspx?spfx=true&dest=${appPortalUrl}`,
                            "websiteUrl": portalUrl,
                            "searchUrl": `https://${searchUrlPath}/_layouts/15/search.aspx?q={searchQuery}`,
                            "scopes": ["personal"],
                            "supportedPlatform": ["desktop"]
                        }
                    ],
                    "permissions": [
                        "identity",
                        "messageTeamMembers"
                    ],
                    "validDomains": [
                        domain,
                        "*.login.microsoftonline.com",
                        "*.sharepoint.com",
                        "*.sharepoint-df.com",
                        "spoppe-a.akamaihd.net",
                        "spoprod-a.akamaihd.net",
                        "resourceseng.blob.core.windows.net",
                        "msft.spoppe.com"
                    ],
                    "webApplicationInfo": {
                        "id": "00000003-0000-0ff1-ce00-000000000000",
                        "resource": `https://${domain}`
                    }
                };
                const manifestString = JSON.stringify(manifest, null, 2);
                try {
                    // we need this to be able to inject mock AdmZip for testing
                    /* c8 ignore next 3 */
                    if (!this.archive) {
                        this.archive = new AdmZip();
                    }
                    this.archive.addFile('manifest.json', Buffer.alloc(manifestString.length, manifestString, 'utf8'));
                    this.archive.addLocalFile(coloredIconPath, undefined, coloredIconFileName);
                    this.archive.addLocalFile(outlineIconPath, undefined, outlineIconFileName);
                    this.archive.writeZip(`${args.options.appName}.zip`);
                }
                catch (ex) {
                    throw ex.message;
                }
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getWeb(args, logger) {
        if (this.verbose) {
            logger.logToStderr(`Checking if site ${args.options.url} exists...`);
        }
        const options = {
            webUrl: args.options.portalUrl,
            output: 'json',
            debug: this.debug,
            verbose: this.verbose
        };
        return Cli_1.Cli.executeCommandWithOutput(spoWebGetCommand, { options: Object.assign(Object.assign({}, options), { _: [] }) });
    }
}
_VivaConnectionsAppCreateCommand_instances = new WeakSet(), _VivaConnectionsAppCreateCommand_initOptions = function _VivaConnectionsAppCreateCommand_initOptions() {
    this.options.unshift({ option: '--portalUrl <portalUrl>' }, { option: '--appName <appName>' }, { option: '--description <description>' }, { option: '--longDescription <longDescription>' }, { option: '--privacyPolicyUrl [privacyPolicyUrl]' }, { option: '--termsOfUseUrl [termsOfUseUrl]' }, { option: '--companyName <companyName>' }, { option: '--companyWebsiteUrl <companyWebsiteUrl>' }, { option: '--coloredIconPath <coloredIconPath>' }, { option: '--outlineIconPath <outlineIconPath>' }, { option: '--accentColor [accentColor]' }, { option: '--force' });
}, _VivaConnectionsAppCreateCommand_initValidators = function _VivaConnectionsAppCreateCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.appName.length > 30) {
            return `App name must not exceed 30 characters`;
        }
        if (args.options.description &&
            args.options.description.length > 80) {
            return 'Description must not exceed 80 characters';
        }
        if (args.options.longDescription &&
            args.options.longDescription.length > 4000) {
            return 'Long description must not exceed 4000 characters';
        }
        const appFilePath = path.resolve(`${args.options.appName}.zip`);
        if (fs.existsSync(appFilePath) && !args.options.force) {
            return `File ${appFilePath} already exists. Delete the file or use the --force option to overwrite the existing file`;
        }
        const coloredIconPath = path.resolve(args.options.coloredIconPath);
        if (!fs.existsSync(coloredIconPath)) {
            return `File ${coloredIconPath} doesn't exist`;
        }
        const outlineIconPath = path.resolve(args.options.outlineIconPath);
        if (!fs.existsSync(outlineIconPath)) {
            return `File ${outlineIconPath} doesn't exist`;
        }
        return true;
    }));
};
module.exports = new VivaConnectionsAppCreateCommand();
//# sourceMappingURL=connections-app-create.js.map