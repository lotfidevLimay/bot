"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SpfxPackageGenerateCommand_instances, _SpfxPackageGenerateCommand_initTelemetry, _SpfxPackageGenerateCommand_initOptions, _SpfxPackageGenerateCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const AdmZip = require("adm-zip");
const fs = require("fs");
const os = require("os");
const path = require("path");
const uuid_1 = require("uuid");
const fsUtil_1 = require("../../../../utils/fsUtil");
const AnonymousCommand_1 = require("../../../base/AnonymousCommand");
const commands_1 = require("../../commands");
class SpfxPackageGenerateCommand extends AnonymousCommand_1.default {
    constructor() {
        super();
        _SpfxPackageGenerateCommand_instances.add(this);
        __classPrivateFieldGet(this, _SpfxPackageGenerateCommand_instances, "m", _SpfxPackageGenerateCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _SpfxPackageGenerateCommand_instances, "m", _SpfxPackageGenerateCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _SpfxPackageGenerateCommand_instances, "m", _SpfxPackageGenerateCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.PACKAGE_GENERATE;
    }
    get description() {
        return 'Generates SharePoint Framework solution package with a no-framework web part rendering the specified HTML snippet';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const supportedHosts = ['SharePointWebPart'];
            if (args.options.enableForTeams === 'tab' || args.options.enableForTeams === 'all') {
                supportedHosts.push('TeamsTab');
            }
            if (args.options.enableForTeams === 'personalApp' || args.options.enableForTeams === 'all') {
                supportedHosts.push('TeamsPersonalApp');
            }
            const tokens = {
                clientSideAssetsFeatureId: SpfxPackageGenerateCommand.generateNewId(),
                developerName: args.options.developerName || 'Contoso',
                developerWebsiteUrl: args.options.developerWebsiteUrl || 'https://contoso.com/my-app',
                developerPrivacyUrl: args.options.developerPrivacyUrl || 'https://contoso.com/privacy',
                developerTermsOfUseUrl: args.options.developerTermsOfUseUrl || 'https://contoso.com/terms-of-use',
                developerMpnId: args.options.developerMpnId || '000000',
                exposePageContextGlobally: args.options.exposePageContextGlobally ? '!0' : '!1',
                exposeTeamsContextGlobally: args.options.exposeTeamsContextGlobally ? '!0' : '!1',
                html: args.options.html.replace(/"/g, '\\"').replace(/\r\n/g, ' ').replace(/\n/g, ' '),
                packageName: SpfxPackageGenerateCommand.getSafePackageName(args.options.webPartTitle),
                productId: SpfxPackageGenerateCommand.generateNewId(),
                skipFeatureDeployment: (args.options.allowTenantWideDeployment === true).toString(),
                supportedHosts: JSON.stringify(supportedHosts).replace(/"/g, '&quot;'),
                webPartId: SpfxPackageGenerateCommand.generateNewId(),
                webPartFeatureName: `${args.options.webPartTitle} Feature`,
                webPartFeatureDescription: `A feature which activates the Client-Side WebPart named ${args.options.webPartTitle}`,
                webPartAlias: SpfxPackageGenerateCommand.getWebPartAlias(args.options.webPartTitle),
                webPartName: args.options.webPartTitle,
                webPartSafeName: SpfxPackageGenerateCommand.getSafeWebPartName(args.options.webPartTitle),
                webPartDescription: args.options.webPartDescription,
                webPartModule: SpfxPackageGenerateCommand.getSafePackageName(args.options.webPartTitle)
            };
            let tmpDir = undefined;
            let error;
            try {
                if (this.verbose) {
                    logger.log(`Creating temp folder...`);
                }
                tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cli-spfx'));
                if (this.debug) {
                    logger.log(`Temp folder created at ${tmpDir}`);
                }
                if (this.verbose) {
                    logger.log('Copying files...');
                }
                const src = path.join(__dirname, 'package-generate', 'assets');
                fsUtil_1.fsUtil.copyRecursiveSync(src, tmpDir, s => SpfxPackageGenerateCommand.replaceTokens(s, tokens));
                const files = fsUtil_1.fsUtil.readdirR(tmpDir);
                if (this.verbose) {
                    logger.log('Processing files...');
                }
                files.forEach(filePath => {
                    if (this.debug) {
                        logger.log(`Processing ${filePath}...`);
                    }
                    if (!SpfxPackageGenerateCommand.isBinaryFile(filePath)) {
                        if (this.verbose) {
                            logger.log('Replacing tokens...');
                        }
                        let fileContents = fs.readFileSync(filePath, 'utf-8');
                        if (this.debug) {
                            logger.log('Before:');
                            logger.log(fileContents);
                        }
                        fileContents = SpfxPackageGenerateCommand.replaceTokens(fileContents, tokens);
                        if (this.debug) {
                            logger.log('After:');
                            logger.log(fileContents);
                        }
                        fs.writeFileSync(filePath, fileContents, { encoding: 'utf-8' });
                    }
                    else {
                        if (this.verbose) {
                            logger.log(`Binary file. Skipping replacing tokens in contents`);
                        }
                    }
                });
                if (this.verbose) {
                    logger.log('Creating .sppkg file...');
                }
                // we need this to be able to inject mock AdmZip for testing
                /* c8 ignore next 3 */
                if (!this.archive) {
                    this.archive = new AdmZip();
                }
                const filesToZip = fsUtil_1.fsUtil.readdirR(tmpDir);
                filesToZip.forEach(f => {
                    if (this.debug) {
                        logger.log(`Adding ${f} to archive...`);
                    }
                    this.archive.addLocalFile(f, path.relative(tmpDir, path.dirname(f)), path.basename(f));
                });
                if (this.debug) {
                    logger.log('Writing archive...');
                }
                this.archive.writeZip(`${args.options.packageName}.sppkg`);
            }
            catch (err) {
                error = err.message;
            }
            finally {
                try {
                    if (tmpDir) {
                        if (this.verbose) {
                            logger.log(`Deleting temp folder at ${tmpDir}...`);
                        }
                        fs.rmdirSync(tmpDir, { recursive: true });
                    }
                    if (error) {
                        throw error;
                    }
                }
                catch (ex) {
                    if (ex === error) {
                        throw ex;
                    }
                    throw `An error has occurred while removing the temp folder at ${tmpDir}. Please remove it manually.`;
                }
            }
        });
    }
    static replaceTokens(s, tokens) {
        return s.replace(/\$([^\$]+)\$/g, (substring, token) => {
            if (tokens[token]) {
                return tokens[token];
            }
            else {
                return substring;
            }
        });
    }
    static isBinaryFile(filePath) {
        return filePath.endsWith('.png');
    }
    static getSafePackageName(packageName) {
        return packageName.toLowerCase().replace(/[^a-zA-Z0-9]/g, '-');
    }
    static getSafeWebPartName(webPartName) {
        return webPartName.replace(/ /g, '-');
    }
    static getWebPartAlias(webPartName) {
        return 'AutoWP' + webPartName.replace(/[^a-zA-Z0-9]/g, '').substr(0, 40);
    }
}
_SpfxPackageGenerateCommand_instances = new WeakSet(), _SpfxPackageGenerateCommand_initTelemetry = function _SpfxPackageGenerateCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            allowTenantWideDeployment: args.options.allowTenantWideDeployment === true,
            developerMpnId: typeof args.options.developerMpnId !== 'undefined',
            developerName: typeof args.options.developerName !== 'undefined',
            developerPrivacyUrl: typeof args.options.developerPrivacyUrl !== 'undefined',
            developerTermsOfUseUrl: typeof args.options.developerTermsOfUseUrl !== 'undefined',
            developerWebsiteUrl: typeof args.options.developerWebsiteUrl !== 'undefined',
            enableForTeams: args.options.enableForTeams,
            exposePageContextGlobally: args.options.exposePageContextGlobally === true,
            exposeTeamsContextGlobally: args.options.exposeTeamsContextGlobally === true
        });
    });
}, _SpfxPackageGenerateCommand_initOptions = function _SpfxPackageGenerateCommand_initOptions() {
    this.options.unshift({ option: '-t, --webPartTitle <webPartTitle>' }, { option: '-d, --webPartDescription <webPartDescription>' }, { option: '-n, --packageName <packageName>' }, { option: '--html <html>' }, {
        option: '--enableForTeams [enableForTeams]',
        autocomplete: SpfxPackageGenerateCommand.enableForTeamsOptions
    }, { option: '--exposePageContextGlobally' }, { option: '--exposeTeamsContextGlobally' }, { option: '--allowTenantWideDeployment' }, { option: '--developerName [developerName]' }, { option: '--developerPrivacyUrl [developerPrivacyUrl]' }, { option: '--developerTermsOfUseUrl [developerTermsOfUseUrl]' }, { option: '--developerWebsiteUrl [developerWebsiteUrl]' }, { option: '--developerMpnId [developerMpnId]' });
}, _SpfxPackageGenerateCommand_initValidators = function _SpfxPackageGenerateCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.enableForTeams &&
            SpfxPackageGenerateCommand.enableForTeamsOptions.indexOf(args.options.enableForTeams) < 0) {
            return `${args.options.enableForTeams} is not a valid value for enableForTeams. Allowed values are: ${SpfxPackageGenerateCommand.enableForTeamsOptions.join(', ')}`;
        }
        return true;
    }));
};
SpfxPackageGenerateCommand.enableForTeamsOptions = ['tab', 'personalApp', 'all'];
SpfxPackageGenerateCommand.generateNewId = () => {
    return (0, uuid_1.v4)();
};
module.exports = new SpfxPackageGenerateCommand();
//# sourceMappingURL=package-generate.js.map