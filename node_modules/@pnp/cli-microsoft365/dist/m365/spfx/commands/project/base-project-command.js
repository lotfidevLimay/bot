"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseProjectCommand = void 0;
const fs = require("fs");
const path = require("path");
const formatting_1 = require("../../../../utils/formatting");
const fsUtil_1 = require("../../../../utils/fsUtil");
const AnonymousCommand_1 = require("../../../base/AnonymousCommand");
const project_model_1 = require("./project-model");
class BaseProjectCommand extends AnonymousCommand_1.default {
    constructor() {
        super(...arguments);
        this.projectRootPath = null;
    }
    getProject(projectRootPath) {
        const project = {
            path: projectRootPath
        };
        const gitignorePath = path.join(projectRootPath, '.gitignore');
        if (fs.existsSync(gitignorePath)) {
            try {
                project.gitignore = {
                    source: fs.readFileSync(gitignorePath, 'utf-8')
                };
            }
            catch (_a) { }
        }
        const npmignorePath = path.join(projectRootPath, '.npmignore');
        if (fs.existsSync(npmignorePath)) {
            try {
                project.npmignore = {
                    source: fs.readFileSync(npmignorePath, 'utf-8')
                };
            }
            catch (_b) { }
        }
        const configJsonPath = path.join(projectRootPath, 'config/config.json');
        if (fs.existsSync(configJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(configJsonPath, 'utf-8'));
                project.configJson = JSON.parse(source);
                project.configJson.source = source;
            }
            catch (_c) { }
        }
        const copyAssetsJsonPath = path.join(projectRootPath, 'config/copy-assets.json');
        if (fs.existsSync(copyAssetsJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(copyAssetsJsonPath, 'utf-8'));
                project.copyAssetsJson = JSON.parse(source);
                project.copyAssetsJson.source = source;
            }
            catch (_d) { }
        }
        const deployAzureStorageJsonPath = path.join(projectRootPath, 'config/deploy-azure-storage.json');
        if (fs.existsSync(deployAzureStorageJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(deployAzureStorageJsonPath, 'utf-8'));
                project.deployAzureStorageJson = JSON.parse(source);
                project.deployAzureStorageJson.source = source;
            }
            catch (_e) { }
        }
        const packageJsonPath = path.join(projectRootPath, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(packageJsonPath, 'utf-8'));
                project.packageJson = JSON.parse(source);
                project.packageJson.source = source;
            }
            catch (_f) { }
        }
        const packageSolutionJsonPath = path.join(projectRootPath, 'config/package-solution.json');
        if (fs.existsSync(packageSolutionJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(packageSolutionJsonPath, 'utf-8'));
                project.packageSolutionJson = JSON.parse(source);
                project.packageSolutionJson.source = source;
            }
            catch (_g) { }
        }
        const serveJsonPath = path.join(projectRootPath, 'config/serve.json');
        if (fs.existsSync(serveJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(serveJsonPath, 'utf-8'));
                project.serveJson = JSON.parse(source);
                project.serveJson.source = source;
            }
            catch (_h) { }
        }
        const tsConfigJsonPath = path.join(projectRootPath, 'tsconfig.json');
        if (fs.existsSync(tsConfigJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(tsConfigJsonPath, 'utf-8'));
                project.tsConfigJson = JSON.parse(source);
                project.tsConfigJson.source = source;
            }
            catch (_j) { }
        }
        const tsLintJsonPath = path.join(projectRootPath, 'config/tslint.json');
        if (fs.existsSync(tsLintJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(tsLintJsonPath, 'utf-8'));
                project.tsLintJson = JSON.parse(source);
                project.tsLintJson.source = source;
            }
            catch (_k) { }
        }
        const tsLintJsonRootPath = path.join(projectRootPath, 'tslint.json');
        if (fs.existsSync(tsLintJsonRootPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(tsLintJsonRootPath, 'utf-8'));
                project.tsLintJsonRoot = JSON.parse(source);
                project.tsLintJsonRoot.source = source;
            }
            catch (_l) { }
        }
        const writeManifestJsonPath = path.join(projectRootPath, 'config/write-manifests.json');
        if (fs.existsSync(writeManifestJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(writeManifestJsonPath, 'utf-8'));
                project.writeManifestsJson = JSON.parse(source);
                project.writeManifestsJson.source = source;
            }
            catch (_m) { }
        }
        const yoRcJsonPath = path.join(projectRootPath, '.yo-rc.json');
        if (fs.existsSync(yoRcJsonPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(yoRcJsonPath, 'utf-8'));
                project.yoRcJson = JSON.parse(source);
                project.yoRcJson.source = source;
            }
            catch (_o) { }
        }
        const gulpfileJsPath = path.join(projectRootPath, 'gulpfile.js');
        if (fs.existsSync(gulpfileJsPath)) {
            project.gulpfileJs = {
                source: fs.readFileSync(gulpfileJsPath, 'utf-8')
            };
        }
        const esLintRcJsPath = path.join(projectRootPath, '.eslintrc.js');
        if (fs.existsSync(esLintRcJsPath)) {
            project.esLintRcJs = new project_model_1.TsFile(esLintRcJsPath);
        }
        project.vsCode = {};
        const vsCodeSettingsPath = path.join(projectRootPath, '.vscode', 'settings.json');
        if (fs.existsSync(vsCodeSettingsPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(vsCodeSettingsPath, 'utf-8'));
                project.vsCode.settingsJson = JSON.parse(source);
                project.vsCode.settingsJson.source = source;
            }
            catch (_p) { }
        }
        const vsCodeExtensionsPath = path.join(projectRootPath, '.vscode', 'extensions.json');
        if (fs.existsSync(vsCodeExtensionsPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(vsCodeExtensionsPath, 'utf-8'));
                project.vsCode.extensionsJson = JSON.parse(source);
                project.vsCode.extensionsJson.source = source;
            }
            catch (_q) { }
        }
        const vsCodeLaunchPath = path.join(projectRootPath, '.vscode', 'launch.json');
        if (fs.existsSync(vsCodeLaunchPath)) {
            try {
                const source = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(vsCodeLaunchPath, 'utf-8'));
                project.vsCode.launchJson = JSON.parse(source);
                project.vsCode.launchJson.source = source;
            }
            catch (_r) { }
        }
        const srcFiles = fsUtil_1.fsUtil.readdirR(path.join(projectRootPath, 'src'));
        const manifestFiles = srcFiles.filter(f => f.endsWith('.manifest.json'));
        const manifests = manifestFiles.map((f) => {
            const manifestStr = formatting_1.formatting.removeSingleLineComments(fs.readFileSync(f, 'utf-8'));
            const manifest = formatting_1.formatting.parseJsonWithBom(manifestStr);
            manifest.path = f;
            manifest.source = manifestStr;
            return manifest;
        });
        project.manifests = manifests;
        const tsFiles = srcFiles.filter(f => f.endsWith('.ts') || f.endsWith('.tsx'));
        project.tsFiles = tsFiles.map(f => new project_model_1.TsFile(f));
        const scssFiles = srcFiles.filter(f => f.endsWith('.scss'));
        project.scssFiles = scssFiles.map(f => new project_model_1.ScssFile(f));
        return project;
    }
    getProjectRoot(folderPath) {
        const packageJsonPath = path.resolve(folderPath, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
            return folderPath;
        }
        else {
            const parentPath = path.resolve(folderPath, `..${path.sep}`);
            if (parentPath !== folderPath) {
                return this.getProjectRoot(parentPath);
            }
            else {
                return null;
            }
        }
    }
    getProjectVersion() {
        const yoRcPath = path.resolve(this.projectRootPath, '.yo-rc.json');
        if (fs.existsSync(yoRcPath)) {
            try {
                const yoRc = JSON.parse(fs.readFileSync(yoRcPath, 'utf-8'));
                if (yoRc && yoRc['@microsoft/generator-sharepoint']) {
                    const version = yoRc['@microsoft/generator-sharepoint'].version;
                    if (version) {
                        switch (yoRc['@microsoft/generator-sharepoint'].environment) {
                            case 'onprem19':
                                return '1.4.1';
                            case 'onprem':
                                return '1.1.0';
                            default:
                                return version;
                        }
                    }
                }
            }
            catch (_a) { }
        }
        const packageJsonPath = path.resolve(this.projectRootPath, 'package.json');
        try {
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
            if (packageJson &&
                packageJson.dependencies &&
                packageJson.dependencies['@microsoft/sp-core-library']) {
                const coreLibVersion = packageJson.dependencies['@microsoft/sp-core-library'];
                return coreLibVersion.replace(/[^0-9\.]/g, '');
            }
        }
        catch (_b) { }
        return undefined;
    }
}
exports.BaseProjectCommand = BaseProjectCommand;
//# sourceMappingURL=base-project-command.js.map