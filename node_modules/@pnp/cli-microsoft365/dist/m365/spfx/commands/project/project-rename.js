"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SpfxProjectRenameCommand_instances, _SpfxProjectRenameCommand_initTelemetry, _SpfxProjectRenameCommand_initOptions;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const uuid_1 = require("uuid");
const Command_1 = require("../../../../Command");
const commands_1 = require("../../commands");
const base_project_command_1 = require("./base-project-command");
class SpfxProjectRenameCommand extends base_project_command_1.BaseProjectCommand {
    constructor() {
        super();
        _SpfxProjectRenameCommand_instances.add(this);
        this.generateNewId = () => {
            return (0, uuid_1.v4)();
        };
        this.replacePackageJsonContent = (filePath, args, logger) => {
            if (!fs.existsSync(filePath)) {
                return;
            }
            const existingContent = fs.readFileSync(filePath, 'utf-8');
            const updatedContent = JSON.parse(existingContent);
            if (updatedContent &&
                updatedContent.name) {
                updatedContent.name = args.options.newName;
            }
            const updatedContentString = JSON.stringify(updatedContent, null, 2);
            if (updatedContentString !== existingContent) {
                fs.writeFileSync(filePath, updatedContentString, 'utf-8');
                if (this.debug) {
                    logger.logToStderr(`Updated ${path.basename(filePath)}`);
                }
            }
        };
        this.replaceYoRcJsonContent = (filePath, newId, args, logger) => {
            if (!fs.existsSync(filePath)) {
                return;
            }
            const existingContent = fs.readFileSync(filePath, 'utf-8');
            const updatedContent = JSON.parse(existingContent);
            if (updatedContent &&
                updatedContent['@microsoft/generator-sharepoint'] &&
                updatedContent['@microsoft/generator-sharepoint'].libraryName) {
                updatedContent['@microsoft/generator-sharepoint'].libraryName = args.options.newName;
            }
            if (updatedContent &&
                updatedContent['@microsoft/generator-sharepoint'] &&
                updatedContent['@microsoft/generator-sharepoint'].solutionName) {
                updatedContent['@microsoft/generator-sharepoint'].solutionName = args.options.newName;
            }
            if (updatedContent &&
                updatedContent['@microsoft/generator-sharepoint'] &&
                updatedContent['@microsoft/generator-sharepoint'].libraryId &&
                args.options.generateNewId) {
                updatedContent['@microsoft/generator-sharepoint'].libraryId = newId;
            }
            const updatedContentString = JSON.stringify(updatedContent, null, 2);
            if (updatedContentString !== existingContent) {
                fs.writeFileSync(filePath, updatedContentString, 'utf-8');
                if (this.debug) {
                    logger.logToStderr(`Updated ${path.basename(filePath)}`);
                }
            }
        };
        this.replacePackageSolutionJsonContent = (filePath, projectName, newId, args, logger) => {
            if (!fs.existsSync(filePath)) {
                return;
            }
            const existingContent = fs.readFileSync(filePath, 'utf-8');
            const updatedContent = JSON.parse(existingContent);
            if (updatedContent &&
                updatedContent.solution &&
                updatedContent.solution.name) {
                updatedContent.solution.name = updatedContent.solution.name.replace(new RegExp(projectName, 'g'), args.options.newName);
            }
            if (updatedContent &&
                updatedContent.solution &&
                updatedContent.solution.id &&
                args.options.generateNewId) {
                updatedContent.solution.id = newId;
            }
            if (updatedContent &&
                updatedContent.paths &&
                updatedContent.paths.zippedPackage) {
                updatedContent.paths.zippedPackage = updatedContent.paths.zippedPackage.replace(new RegExp(projectName, 'g'), args.options.newName);
            }
            const updatedContentString = JSON.stringify(updatedContent, null, 2);
            if (updatedContentString !== existingContent) {
                fs.writeFileSync(filePath, updatedContentString, 'utf-8');
                if (this.debug) {
                    logger.logToStderr(`Updated ${path.basename(filePath)}`);
                }
            }
        };
        this.replaceDeployAzureStorageJsonContent = (filePath, args, logger) => {
            if (!fs.existsSync(filePath)) {
                return;
            }
            const existingContent = fs.readFileSync(filePath, 'utf-8');
            const updatedContent = JSON.parse(existingContent);
            if (updatedContent &&
                updatedContent.container) {
                updatedContent.container = args.options.newName;
            }
            const updatedContentString = JSON.stringify(updatedContent, null, 2);
            if (updatedContentString !== existingContent) {
                fs.writeFileSync(filePath, updatedContentString, 'utf-8');
                if (this.debug) {
                    logger.logToStderr(`Updated ${path.basename(filePath)}`);
                }
            }
        };
        this.replaceReadMeContent = (filePath, projectName, args, logger) => {
            if (!fs.existsSync(filePath)) {
                return;
            }
            const existingContent = fs.readFileSync(filePath, 'utf-8');
            const updatedContent = existingContent.replace(new RegExp(projectName, 'g'), args.options.newName);
            if (updatedContent !== existingContent) {
                fs.writeFileSync(filePath, updatedContent, 'utf-8');
                if (this.debug) {
                    logger.logToStderr(`Updated ${path.basename(filePath)}`);
                }
            }
        };
        __classPrivateFieldGet(this, _SpfxProjectRenameCommand_instances, "m", _SpfxProjectRenameCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _SpfxProjectRenameCommand_instances, "m", _SpfxProjectRenameCommand_initOptions).call(this);
    }
    get name() {
        return commands_1.default.PROJECT_RENAME;
    }
    get description() {
        return 'Renames SharePoint Framework project';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.projectRootPath = this.getProjectRoot(process.cwd());
            if (this.projectRootPath === null) {
                throw new Command_1.CommandError(`Couldn't find project root folder`, SpfxProjectRenameCommand.ERROR_NO_PROJECT_ROOT_FOLDER);
            }
            const packageJson = this.getProject(this.projectRootPath).packageJson;
            const projectName = packageJson.name;
            let newId = '';
            if (args.options.generateNewId) {
                newId = this.generateNewId();
                if (this.debug) {
                    logger.logToStderr('Created new solution id');
                    logger.logToStderr(newId);
                }
            }
            if (this.debug) {
                logger.logToStderr(`Renaming SharePoint Framework project to '${args.options.newName}'`);
            }
            try {
                this.replacePackageJsonContent(path.join(this.projectRootPath, 'package.json'), args, logger);
                this.replaceYoRcJsonContent(path.join(this.projectRootPath, '.yo-rc.json'), newId, args, logger);
                this.replacePackageSolutionJsonContent(path.join(this.projectRootPath, 'config', 'package-solution.json'), projectName, newId, args, logger);
                this.replaceDeployAzureStorageJsonContent(path.join(this.projectRootPath, 'config', 'deploy-azure-storage.json'), args, logger);
                this.replaceReadMeContent(path.join(this.projectRootPath, 'README.md'), projectName, args, logger);
            }
            catch (error) {
                throw new Command_1.CommandError(error);
            }
        });
    }
}
_SpfxProjectRenameCommand_instances = new WeakSet(), _SpfxProjectRenameCommand_initTelemetry = function _SpfxProjectRenameCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            generateNewId: args.options.generateNewId
        });
    });
}, _SpfxProjectRenameCommand_initOptions = function _SpfxProjectRenameCommand_initOptions() {
    this.options.unshift({
        option: '-n, --newName <newName>'
    }, {
        option: '--generateNewId'
    });
};
SpfxProjectRenameCommand.ERROR_NO_PROJECT_ROOT_FOLDER = 1;
module.exports = new SpfxProjectRenameCommand();
//# sourceMappingURL=project-rename.js.map