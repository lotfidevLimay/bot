"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyRule = void 0;
const semver_1 = require("semver");
const JsonRule_1 = require("../../JsonRule");
class DependencyRule extends JsonRule_1.JsonRule {
    constructor(packageName, supportedRange, isDevDep = false) {
        super();
        this.packageName = packageName;
        this.supportedRange = supportedRange;
        this.isDevDep = isDevDep;
    }
    get title() {
        return this.packageName;
    }
    get description() {
        return '';
    }
    get resolution() {
        return `${(this.isDevDep ? 'installDev' : 'install')} ${this.packageName}@${this.supportedRange.includes(' ') ? `"${this.supportedRange}"` : this.supportedRange}`;
    }
    get resolutionType() {
        return 'cmd';
    }
    get severity() {
        return 'Required';
    }
    get file() {
        return './package.json';
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    customCondition(project) {
        return true;
    }
    visit(project, findings) {
        if (!project.packageJson || !this.customCondition(project)) {
            return;
        }
        // if the project has no dependencies, then we assume the package is missing
        let packageNotFound = (this.isDevDep && !project.packageJson.devDependencies) ||
            (!this.isDevDep && !project.packageJson.dependencies);
        let packageVersionFromProject = undefined;
        let minSemVer = null;
        if (!packageNotFound) {
            // try to get the current version of the dependency installed in the
            // project. If not possible, we assume the dependency is missing
            packageVersionFromProject = this.isDevDep ? project.packageJson.devDependencies[this.packageName] : project.packageJson.dependencies[this.packageName];
            if (!packageVersionFromProject) {
                packageNotFound = true;
            }
            else {
                minSemVer = (0, semver_1.coerce)(packageVersionFromProject);
                if (!minSemVer) {
                    packageNotFound = true;
                }
            }
        }
        if (packageNotFound) {
            return this.addFindingWithCustomInfo(this.title, `Install missing package ${this.packageName}`, [{
                    file: this.file,
                    resolution: this.resolution
                }], findings);
        }
        if ((0, semver_1.satisfies)(minSemVer, this.supportedRange)) {
            return;
        }
        const node = this.getAstNodeFromFile(project.packageJson, `${(this.isDevDep ? 'devDependencies' : 'dependencies')}.${this.packageName}`);
        this.addFindingWithCustomInfo(this.title, `Install supported version of the ${this.packageName} package`, [{
                file: this.file,
                resolution: this.resolution,
                position: this.getPositionFromNode(node)
            }], findings);
    }
}
exports.DependencyRule = DependencyRule;
//# sourceMappingURL=DependencyRule.js.map