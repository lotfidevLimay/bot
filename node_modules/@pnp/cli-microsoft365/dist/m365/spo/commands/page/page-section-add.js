"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SpoPageSectionAddCommand_instances, _SpoPageSectionAddCommand_initTelemetry, _SpoPageSectionAddCommand_initOptions, _SpoPageSectionAddCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const request_1 = require("../../../../request");
const validation_1 = require("../../../../utils/validation");
const SpoCommand_1 = require("../../../base/SpoCommand");
const commands_1 = require("../../commands");
const clientsidepages_1 = require("./clientsidepages");
class SpoPageSectionAddCommand extends SpoCommand_1.default {
    constructor() {
        super();
        _SpoPageSectionAddCommand_instances.add(this);
        __classPrivateFieldGet(this, _SpoPageSectionAddCommand_instances, "m", _SpoPageSectionAddCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _SpoPageSectionAddCommand_instances, "m", _SpoPageSectionAddCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _SpoPageSectionAddCommand_instances, "m", _SpoPageSectionAddCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.PAGE_SECTION_ADD;
    }
    get description() {
        return 'Adds section to modern page';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let pageFullName = args.options.name.toLowerCase();
            if (pageFullName.indexOf('.aspx') < 0) {
                pageFullName += '.aspx';
            }
            let canvasContent;
            if (this.verbose) {
                logger.logToStderr(`Retrieving page information...`);
            }
            try {
                let requestOptions = {
                    url: `${args.options.webUrl}/_api/sitepages/pages/GetByUrl('sitepages/${encodeURIComponent(pageFullName)}')?$select=CanvasContent1,IsPageCheckedOutToCurrentUser`,
                    headers: {
                        'accept': 'application/json;odata=nometadata'
                    },
                    responseType: 'json'
                };
                const res = yield request_1.default.get(requestOptions);
                canvasContent = JSON.parse(res.CanvasContent1 || "[{\"controlType\":0,\"pageSettingsSlice\":{\"isDefaultDescription\":true,\"isDefaultThumbnail\":true}}]");
                if (!res.IsPageCheckedOutToCurrentUser) {
                    requestOptions = {
                        url: `${args.options.webUrl}/_api/sitepages/pages/GetByUrl('sitepages/${encodeURIComponent(pageFullName)}')/checkoutpage`,
                        headers: {
                            'accept': 'application/json;odata=nometadata'
                        },
                        responseType: 'json'
                    };
                    return request_1.default.post(requestOptions);
                }
                // get columns
                const columns = canvasContent
                    .filter(c => typeof c.controlType === 'undefined');
                // get unique zoneIndex values given each section can have 1 or more
                // columns each assigned to the zoneIndex of the corresponding section
                const zoneIndices = columns
                    .map(c => c.position.zoneIndex)
                    .filter((value, index, array) => {
                    return array.indexOf(value) === index;
                })
                    .sort();
                // zoneIndex for the new section to add
                const zoneIndex = this.getSectionIndex(zoneIndices, args.options.order);
                // get the list of columns to insert based on the selected template
                const columnsToAdd = this.getColumns(zoneIndex, args.options.sectionTemplate);
                // insert the column in the right place in the array so that
                // it stays sorted ascending by zoneIndex
                let pos = canvasContent.findIndex(c => typeof c.controlType === 'undefined' && c.position.zoneIndex > zoneIndex);
                if (pos === -1) {
                    pos = canvasContent.length - 1;
                }
                canvasContent.splice(pos, 0, ...columnsToAdd);
                requestOptions = {
                    url: `${args.options.webUrl}/_api/sitepages/pages/GetByUrl('sitepages/${encodeURIComponent(pageFullName)}')/savepage`,
                    headers: {
                        'accept': 'application/json;odata=nometadata',
                        'content-type': 'application/json;odata=nometadata'
                    },
                    data: {
                        CanvasContent1: JSON.stringify(canvasContent)
                    },
                    responseType: 'json'
                };
                yield request_1.default.post(requestOptions);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getSectionIndex(zoneIndices, order) {
        // zoneIndex of the first column on the page
        const minIndex = zoneIndices.length === 0 ? 0 : zoneIndices[0];
        // zoneIndex of the last column on the page
        const maxIndex = zoneIndices.length === 0 ? 0 : zoneIndices[zoneIndices.length - 1];
        if (!order || order > zoneIndices.length) {
            // no order specified, add section to the end
            return maxIndex === 0 ? 1 : maxIndex * 2;
        }
        // add to the beginning
        if (order === 1) {
            return minIndex / 2;
        }
        return zoneIndices[order - 2] + ((zoneIndices[order - 1] - zoneIndices[order - 2]) / 2);
    }
    getColumns(zoneIndex, sectionTemplate) {
        const columns = [];
        let sectionIndex = 1;
        switch (sectionTemplate) {
            case 'OneColumnFullWidth':
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 0));
                break;
            case 'TwoColumn':
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 6));
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 6));
                break;
            case 'ThreeColumn':
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 4));
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 4));
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 4));
                break;
            case 'TwoColumnLeft':
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 8));
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 4));
                break;
            case 'TwoColumnRight':
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 4));
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 8));
                break;
            case 'OneColumn':
            default:
                columns.push(this.getColumn(zoneIndex, sectionIndex++, 12));
                break;
        }
        return columns;
    }
    getColumn(zoneIndex, sectionIndex, sectionFactor) {
        return {
            displayMode: 2,
            position: {
                zoneIndex: zoneIndex,
                sectionIndex: sectionIndex,
                sectionFactor: sectionFactor,
                layoutIndex: 1
            },
            emphasis: {}
        };
    }
}
_SpoPageSectionAddCommand_instances = new WeakSet(), _SpoPageSectionAddCommand_initTelemetry = function _SpoPageSectionAddCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            order: typeof args.options.order !== 'undefined'
        });
    });
}, _SpoPageSectionAddCommand_initOptions = function _SpoPageSectionAddCommand_initOptions() {
    this.options.unshift({
        option: '-n, --name <name>'
    }, {
        option: '-u, --webUrl <webUrl>'
    }, {
        option: '-t, --sectionTemplate <sectionTemplate>'
    }, {
        option: '--order [order]'
    });
}, _SpoPageSectionAddCommand_initValidators = function _SpoPageSectionAddCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (!(args.options.sectionTemplate in clientsidepages_1.CanvasSectionTemplate)) {
            return `${args.options.sectionTemplate} is not a valid section template. Allowed values are OneColumn|OneColumnFullWidth|TwoColumn|ThreeColumn|TwoColumnLeft|TwoColumnRight`;
        }
        if (typeof args.options.order !== 'undefined') {
            if (!(0, util_1.isNumber)(args.options.order) || args.options.order < 1) {
                return 'The value of parameter order must be 1 or higher';
            }
        }
        return validation_1.validation.isValidSharePointUrl(args.options.webUrl);
    }));
};
module.exports = new SpoPageSectionAddCommand();
//# sourceMappingURL=page-section-add.js.map