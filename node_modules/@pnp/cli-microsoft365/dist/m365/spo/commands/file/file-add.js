"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SpoFileAddCommand_instances, _SpoFileAddCommand_initTelemetry, _SpoFileAddCommand_initOptions, _SpoFileAddCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const uuid_1 = require("uuid");
const request_1 = require("../../../../request");
const fsUtil_1 = require("../../../../utils/fsUtil");
const spo_1 = require("../../../../utils/spo");
const urlUtil_1 = require("../../../../utils/urlUtil");
const validation_1 = require("../../../../utils/validation");
const SpoCommand_1 = require("../../../base/SpoCommand");
const commands_1 = require("../../commands");
class SpoFileAddCommand extends SpoCommand_1.default {
    constructor() {
        super();
        _SpoFileAddCommand_instances.add(this);
        this.fileChunkingThreshold = 250 * 1024 * 1024; // max 250 MB
        this.fileChunkSize = 250 * 1024 * 1024; // max fileChunkingThreshold
        this.fileChunkRetryAttempts = 5;
        __classPrivateFieldGet(this, _SpoFileAddCommand_instances, "m", _SpoFileAddCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _SpoFileAddCommand_instances, "m", _SpoFileAddCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _SpoFileAddCommand_instances, "m", _SpoFileAddCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.FILE_ADD;
    }
    get description() {
        return 'Uploads file to the specified folder';
    }
    allowUnknownOptions() {
        return true;
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderPath = urlUtil_1.urlUtil.getServerRelativePath(args.options.webUrl, args.options.folder);
            const fullPath = path.resolve(args.options.path);
            const fileName = fsUtil_1.fsUtil.getSafeFileName(path.basename(fullPath));
            let isCheckedOut = false;
            let listSettings;
            if (this.debug) {
                logger.logToStderr(`folder path: ${folderPath}...`);
            }
            if (this.debug) {
                logger.logToStderr('Check if the specified folder exists.');
                logger.logToStderr('');
            }
            if (this.debug) {
                logger.logToStderr(`file name: ${fileName}...`);
            }
            try {
                try {
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')`,
                        headers: {
                            'accept': 'application/json;odata=nometadata'
                        }
                    };
                    yield request_1.default.get(requestOptions);
                }
                catch (err) {
                    // folder does not exist so will attempt to create the folder tree
                    yield spo_1.spo.ensureFolder(args.options.webUrl, folderPath, logger, this.debug);
                }
                if (args.options.checkOut) {
                    yield this.fileCheckOut(fileName, args.options.webUrl, folderPath);
                    // flag the file is checkedOut by the command
                    // so in case of command failure we can try check it in
                    isCheckedOut = true;
                }
                if (this.verbose) {
                    logger.logToStderr(`Upload file to site ${args.options.webUrl}...`);
                }
                const fileStats = fs.statSync(fullPath);
                const fileSize = fileStats.size;
                if (this.debug) {
                    logger.logToStderr(`File size is ${fileSize} bytes`);
                }
                // only up to 250 MB are allowed in a single request
                if (fileSize > this.fileChunkingThreshold) {
                    const fileChunkCount = Math.ceil(fileSize / this.fileChunkSize);
                    if (this.verbose) {
                        logger.logToStderr(`Uploading ${fileSize} bytes in ${fileChunkCount} chunks...`);
                    }
                    // initiate chunked upload session
                    const uploadId = (0, uuid_1.v4)();
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files/GetByPathOrAddStub(DecodedUrl='${encodeURIComponent(fileName)}')/StartUpload(uploadId=guid'${uploadId}')`,
                        headers: {
                            'accept': 'application/json;odata=nometadata'
                        }
                    };
                    yield request_1.default.post(requestOptions);
                    // session started successfully, now upload our file chunks
                    const fileUploadInfo = {
                        Name: fileName,
                        FilePath: fullPath,
                        WebUrl: args.options.webUrl,
                        FolderPath: folderPath,
                        Id: uploadId,
                        RetriesLeft: this.fileChunkRetryAttempts,
                        Position: 0,
                        Size: fileSize
                    };
                    try {
                        yield new Promise((resolve, reject) => {
                            this.uploadFileChunks(fileUploadInfo, logger, resolve, reject);
                        });
                        if (this.verbose) {
                            logger.logToStderr(`Finished uploading ${fileUploadInfo.Position} bytes in ${fileChunkCount} chunks`);
                        }
                    }
                    catch (err) {
                        if (this.verbose) {
                            logger.logToStderr('Cancelling upload session due to error...');
                        }
                        const requestOptions = {
                            url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files('${encodeURIComponent(fileName)}')/cancelupload(uploadId=guid'${uploadId}')`,
                            headers: {
                                'accept': 'application/json;odata=nometadata'
                            }
                        };
                        try {
                            yield request_1.default.post(requestOptions);
                            throw err;
                        }
                        catch (err) {
                            if (this.debug) {
                                logger.logToStderr(`Failed to cancel upload session: ${err}`);
                            }
                            throw err;
                        }
                    }
                }
                else {
                    // upload small file in a single request
                    const fileBody = fs.readFileSync(fullPath);
                    const bodyLength = fileBody.byteLength;
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files/Add(url='${encodeURIComponent(fileName)}', overwrite=true)`,
                        data: fileBody,
                        headers: {
                            'accept': 'application/json;odata=nometadata',
                            'content-length': bodyLength
                        },
                        maxBodyLength: this.fileChunkingThreshold
                    };
                    yield request_1.default.post(requestOptions);
                }
                if (args.options.contentType || args.options.publish || args.options.approve) {
                    listSettings = yield this.getFileParentList(fileName, args.options.webUrl, folderPath, logger);
                    if (args.options.contentType) {
                        yield this.listHasContentType(args.options.contentType, args.options.webUrl, listSettings, logger);
                    }
                }
                // check if there are unknown options
                // and map them as fields to update
                const fieldsToUpdate = this.mapUnknownOptionsAsFieldValue(args.options);
                if (args.options.contentType) {
                    fieldsToUpdate.push({
                        FieldName: 'ContentType',
                        FieldValue: args.options.contentType
                    });
                }
                if (fieldsToUpdate.length > 0) {
                    // perform list item update and checkin
                    yield this.validateUpdateListItem(args.options.webUrl, folderPath, fileName, fieldsToUpdate, logger, args.options.checkInComment);
                }
                else if (isCheckedOut) {
                    // perform checkin
                    yield this.fileCheckIn(args, fileName);
                }
                // approve and publish cannot be used together
                // when approve is used it will automatically publish the file
                // so then no need to publish afterwards
                if (args.options.approve) {
                    if (this.verbose) {
                        logger.logToStderr(`Approve file ${fileName}`);
                    }
                    // approve the existing file with given comment
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files('${encodeURIComponent(fileName)}')/approve(comment='${encodeURIComponent(args.options.approveComment || '')}')`,
                        headers: {
                            'accept': 'application/json;odata=nometadata'
                        },
                        responseType: 'json'
                    };
                    yield request_1.default.post(requestOptions);
                }
                else if (args.options.publish) {
                    if (listSettings.EnableModeration && listSettings.EnableMinorVersions) {
                        throw 'The file cannot be published without approval. Moderation for this list is enabled. Use the --approve option instead of --publish to approve and publish the file';
                    }
                    if (this.verbose) {
                        logger.logToStderr(`Publish file ${fileName}`);
                    }
                    // publish the existing file with given comment
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files('${encodeURIComponent(fileName)}')/publish(comment='${encodeURIComponent(args.options.publishComment || '')}')`,
                        headers: {
                            'accept': 'application/json;odata=nometadata'
                        },
                        responseType: 'json'
                    };
                    yield request_1.default.post(requestOptions);
                }
            }
            catch (err) {
                if (isCheckedOut) {
                    // in a case the command has done checkout
                    // then have to rollback the checkout
                    const requestOptions = {
                        url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files('${encodeURIComponent(fileName)}')/UndoCheckOut()`
                    };
                    try {
                        yield request_1.default.post(requestOptions);
                    }
                    catch (err) {
                        if (this.verbose) {
                            logger.logToStderr('Could not rollback file checkout');
                            logger.logToStderr(err);
                            logger.logToStderr('');
                        }
                    }
                }
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    listHasContentType(contentType, webUrl, listSettings, logger) {
        if (this.verbose) {
            logger.logToStderr(`Getting list of available content types ...`);
        }
        const requestOptions = {
            url: `${webUrl}/_api/web/lists('${listSettings.Id}')/contenttypes?$select=Name,Id`,
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            responseType: 'json'
        };
        return request_1.default.get(requestOptions).then(response => {
            // check if the specified content type is in the list
            for (const ct of response.value) {
                if (ct.Id.StringValue === contentType || ct.Name === contentType) {
                    return Promise.resolve();
                }
            }
            return Promise.reject(`Specified content type '${contentType}' doesn't exist on the target list`);
        });
    }
    fileCheckOut(fileName, webUrl, folder) {
        // check if file already exists, otherwise it can't be checked out
        const requestOptions = {
            url: `${webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folder)}')/Files('${encodeURIComponent(fileName)}')`,
            headers: {
                'accept': 'application/json;odata=nometadata'
            }
        };
        return request_1.default.get(requestOptions)
            .then(() => {
            // checkout the existing file
            const requestOptions = {
                url: `${webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folder)}')/Files('${encodeURIComponent(fileName)}')/CheckOut()`,
                headers: {
                    'accept': 'application/json;odata=nometadata'
                },
                responseType: 'json'
            };
            return request_1.default.post(requestOptions);
        });
    }
    uploadFileChunks(info, logger, resolve, reject) {
        let fd = 0;
        try {
            fd = fs.openSync(info.FilePath, 'r');
            let fileBuffer = Buffer.alloc(this.fileChunkSize);
            const readCount = fs.readSync(fd, fileBuffer, 0, this.fileChunkSize, info.Position);
            fs.closeSync(fd);
            fd = 0;
            const offset = info.Position;
            info.Position += readCount;
            const isLastChunk = info.Position >= info.Size;
            if (isLastChunk) {
                // trim buffer for last chunk
                fileBuffer = fileBuffer.slice(0, readCount);
            }
            const requestOptions = {
                url: `${info.WebUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(info.FolderPath)}')/Files('${encodeURIComponent(info.Name)}')/${isLastChunk ? 'Finish' : 'Continue'}Upload(uploadId=guid'${info.Id}',fileOffset=${offset})`,
                data: fileBuffer,
                headers: {
                    'accept': 'application/json;odata=nometadata',
                    'content-length': readCount
                },
                maxBodyLength: this.fileChunkingThreshold
            };
            request_1.default
                .post(requestOptions)
                .then(() => {
                if (this.verbose) {
                    logger.logToStderr(`Uploaded ${info.Position} of ${info.Size} bytes (${Math.round(100 * info.Position / info.Size)}%)`);
                }
                if (isLastChunk) {
                    resolve();
                }
                else {
                    this.uploadFileChunks(info, logger, resolve, reject);
                }
            })
                .catch((err) => {
                if (--info.RetriesLeft > 0) {
                    if (this.verbose) {
                        logger.logToStderr(`Retrying to upload chunk due to error: ${err}`);
                    }
                    info.Position -= readCount; // rewind
                    this.uploadFileChunks(info, logger, resolve, reject);
                }
                else {
                    reject(err);
                }
            });
        }
        catch (err) {
            if (fd) {
                try {
                    fs.closeSync(fd);
                    /* c8 ignore next */
                }
                catch (_a) { }
            }
            if (--info.RetriesLeft > 0) {
                if (this.verbose) {
                    logger.logToStderr(`Retrying to read chunk due to error: ${err}`);
                }
                this.uploadFileChunks(info, logger, resolve, reject);
            }
            else {
                reject(err);
            }
        }
    }
    getFileParentList(fileName, webUrl, folder, logger) {
        if (this.verbose) {
            logger.logToStderr(`Getting list details in order to get its available content types afterwards...`);
        }
        const requestOptions = {
            url: `${webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folder)}')/Files('${encodeURIComponent(fileName)}')/ListItemAllFields/ParentList?$Select=Id,EnableModeration,EnableVersioning,EnableMinorVersions`,
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            responseType: 'json'
        };
        return request_1.default.get(requestOptions);
    }
    validateUpdateListItem(webUrl, folderPath, fileName, fieldsToUpdate, logger, checkInComment) {
        if (this.verbose) {
            logger.logToStderr(`Validate and update list item values for file ${fileName}`);
        }
        const requestBody = {
            formValues: fieldsToUpdate,
            bNewDocumentUpdate: true,
            checkInComment: checkInComment || ''
        };
        if (this.debug) {
            logger.logToStderr('ValidateUpdateListItem will perform the checkin ...');
            logger.logToStderr('');
        }
        // update the existing file list item fields
        const requestOptions = {
            url: `${webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(folderPath)}')/Files('${encodeURIComponent(fileName)}')/ListItemAllFields/ValidateUpdateListItem()`,
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            data: requestBody,
            responseType: 'json'
        };
        return request_1.default.post(requestOptions)
            .then((res) => {
            // check for field value update for errors
            const fieldValues = res.value;
            for (const fieldValue of fieldValues) {
                if (fieldValue.HasException) {
                    return Promise.reject(`Update field value error: ${JSON.stringify(fieldValues)}`);
                }
            }
            return Promise.resolve();
        })
            .catch((err) => {
            return Promise.reject(err);
        });
    }
    fileCheckIn(args, fileName) {
        const requestOptions = {
            url: `${args.options.webUrl}/_api/web/GetFolderByServerRelativeUrl('${encodeURIComponent(args.options.folder)}')/Files('${encodeURIComponent(fileName)}')/CheckIn(comment='${encodeURIComponent(args.options.checkInComment || '')}',checkintype=0)`,
            headers: {
                'accept': 'application/json;odata=nometadata'
            },
            responseType: 'json'
        };
        return request_1.default.post(requestOptions);
    }
    mapUnknownOptionsAsFieldValue(options) {
        const result = [];
        const excludeOptions = [
            'webUrl',
            'folder',
            'path',
            'contentType',
            'checkOut',
            'checkInComment',
            'approve',
            'approveComment',
            'publish',
            'publishComment',
            'debug',
            'verbose',
            'output',
            '_',
            'u',
            'p',
            'f',
            'o',
            'c'
        ];
        Object.keys(options).forEach(key => {
            if (excludeOptions.indexOf(key) === -1) {
                result.push({ FieldName: key, FieldValue: options[key].toString() });
            }
        });
        return result;
    }
}
_SpoFileAddCommand_instances = new WeakSet(), _SpoFileAddCommand_initTelemetry = function _SpoFileAddCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            contentType: (!(!args.options.contentType)).toString(),
            checkOut: args.options.checkOut || false,
            checkInComment: (!(!args.options.checkInComment)).toString(),
            approve: args.options.approve || false,
            approveComment: (!(!args.options.approveComment)).toString(),
            publish: args.options.publish || false,
            publishComment: (!(!args.options.publishComment)).toString()
        });
    });
}, _SpoFileAddCommand_initOptions = function _SpoFileAddCommand_initOptions() {
    this.options.unshift({
        option: '-u, --webUrl <webUrl>'
    }, {
        option: '-f, --folder <folder>'
    }, {
        option: '-p, --path <path>'
    }, {
        option: '-c, --contentType [contentType]'
    }, {
        option: '--checkOut'
    }, {
        option: '--checkInComment [checkInComment]'
    }, {
        option: '--approve'
    }, {
        option: '--approveComment [approveComment]'
    }, {
        option: '--publish'
    }, {
        option: '--publishComment [publishComment]'
    });
}, _SpoFileAddCommand_initValidators = function _SpoFileAddCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        const isValidSharePointUrl = validation_1.validation.isValidSharePointUrl(args.options.webUrl);
        if (isValidSharePointUrl !== true) {
            return isValidSharePointUrl;
        }
        if (args.options.path && !fs.existsSync(args.options.path)) {
            return 'Specified path of the file to add does not exist';
        }
        if (args.options.publishComment && !args.options.publish) {
            return '--publishComment cannot be used without --publish';
        }
        if (args.options.approveComment && !args.options.approve) {
            return '--approveComment cannot be used without --approve';
        }
        return true;
    }));
};
module.exports = new SpoFileAddCommand();
//# sourceMappingURL=file-add.js.map