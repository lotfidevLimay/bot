"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GraphSubscriptionAddCommand_instances, _GraphSubscriptionAddCommand_initTelemetry, _GraphSubscriptionAddCommand_initOptions, _GraphSubscriptionAddCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = require("../../../../request");
const validation_1 = require("../../../../utils/validation");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
const DEFAULT_EXPIRATION_DELAY_IN_MINUTES_PER_RESOURCE_TYPE = {
    // User, group, other directory resources	4230 minutes (under 3 days)
    "users": 4230,
    "groups": 4230,
    // Mail	4230 minutes (under 3 days)
    "/messages": 4230,
    // Calendar	4230 minutes (under 3 days)
    "/events": 4230,
    // Contacts	4230 minutes (under 3 days)
    "/contacts": 4230,
    // Group conversations	4230 minutes (under 3 days)
    "/conversations": 4230,
    // Drive root items	4230 minutes (under 3 days)
    "/drive/root": 4230,
    // Security alerts	43200 minutes (under 30 days)
    "security/alerts": 43200
};
const DEFAULT_EXPIRATION_DELAY_IN_MINUTES = 4230;
const SAFE_MINUTES_DELTA = 1;
class GraphSubscriptionAddCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _GraphSubscriptionAddCommand_instances.add(this);
        __classPrivateFieldGet(this, _GraphSubscriptionAddCommand_instances, "m", _GraphSubscriptionAddCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _GraphSubscriptionAddCommand_instances, "m", _GraphSubscriptionAddCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _GraphSubscriptionAddCommand_instances, "m", _GraphSubscriptionAddCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.SUBSCRIPTION_ADD;
    }
    get description() {
        return 'Creates a Microsoft Graph subscription';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = {
                changeType: args.options.changeType,
                resource: args.options.resource,
                notificationUrl: args.options.notificationUrl,
                expirationDateTime: this.getExpirationDateTimeOrDefault(logger, args)
            };
            if (args.options.clientState) {
                data["clientState"] = args.options.clientState;
            }
            const requestOptions = {
                url: `${this.resource}/v1.0/subscriptions`,
                headers: {
                    accept: 'application/json;odata.metadata=none',
                    'content-type': 'application/json'
                },
                data,
                responseType: 'json'
            };
            try {
                const res = yield request_1.default.post(requestOptions);
                logger.log(res);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getExpirationDateTimeOrDefault(logger, args) {
        if (args.options.expirationDateTime) {
            if (this.debug) {
                logger.logToStderr(`Expiration date time is specified (${args.options.expirationDateTime}).`);
            }
            return args.options.expirationDateTime;
        }
        if (this.debug) {
            logger.logToStderr(`Expiration date time is not specified. Will try to get appropriate maximum value`);
        }
        const fromNow = (minutes) => {
            // convert minutes in milliseconds
            return new Date(Date.now() + (minutes * 60000));
        };
        const expirationDelayPerResource = DEFAULT_EXPIRATION_DELAY_IN_MINUTES_PER_RESOURCE_TYPE;
        for (const resource in expirationDelayPerResource) {
            if (args.options.resource.indexOf(resource) < 0) {
                continue;
            }
            const resolvedExpirationDelay = expirationDelayPerResource[resource];
            // Compute the actual expirationDateTime argument from now
            const actualExpiration = fromNow(resolvedExpirationDelay - SAFE_MINUTES_DELTA);
            const actualExpirationIsoString = actualExpiration.toISOString();
            if (this.debug) {
                logger.logToStderr(`Matching resource in default values '${args.options.resource}' => '${resource}'`);
                logger.logToStderr(`Resolved expiration delay: ${resolvedExpirationDelay} (safe delta: ${SAFE_MINUTES_DELTA})`);
                logger.logToStderr(`Actual expiration date time: ${actualExpirationIsoString}`);
            }
            if (this.verbose) {
                logger.logToStderr(`An expiration maximum delay is resolved for the resource '${args.options.resource}' : ${resolvedExpirationDelay} minutes.`);
            }
            return actualExpirationIsoString;
        }
        // If an resource specific expiration has not been found, return a default expiration delay
        if (this.verbose) {
            logger.logToStderr(`An expiration maximum delay couldn't be resolved for the resource '${args.options.resource}'. Will use generic default value: ${DEFAULT_EXPIRATION_DELAY_IN_MINUTES} minutes.`);
        }
        const actualExpiration = fromNow(DEFAULT_EXPIRATION_DELAY_IN_MINUTES - SAFE_MINUTES_DELTA);
        const actualExpirationIsoString = actualExpiration.toISOString();
        if (this.debug) {
            logger.logToStderr(`Actual expiration date time: ${actualExpirationIsoString}`);
        }
        return actualExpirationIsoString;
    }
    isValidChangeTypes(changeTypes) {
        const validChangeTypes = ["created", "updated", "deleted"];
        const invalidChangesTypes = changeTypes.split(",").filter(c => validChangeTypes.indexOf(c.trim()) < 0);
        return invalidChangesTypes.length === 0;
    }
}
_GraphSubscriptionAddCommand_instances = new WeakSet(), _GraphSubscriptionAddCommand_initTelemetry = function _GraphSubscriptionAddCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            changeType: args.options.changeType,
            expirationDateTime: typeof args.options.expirationDateTime !== 'undefined',
            clientState: typeof args.options.clientState !== 'undefined'
        });
    });
}, _GraphSubscriptionAddCommand_initOptions = function _GraphSubscriptionAddCommand_initOptions() {
    this.options.unshift({
        option: '-r, --resource <resource>'
    }, {
        option: '-u, --notificationUrl <notificationUrl>'
    }, {
        option: '-c, --changeType <changeType>',
        autocomplete: ['created', 'updated', 'deleted']
    }, {
        option: '-e, --expirationDateTime [expirationDateTime]'
    }, {
        option: '-s, --clientState [clientState]'
    });
}, _GraphSubscriptionAddCommand_initValidators = function _GraphSubscriptionAddCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.notificationUrl.indexOf('https://') !== 0) {
            return `The specified notification URL '${args.options.notificationUrl}' does not start with 'https://'`;
        }
        if (!this.isValidChangeTypes(args.options.changeType)) {
            return `The specified changeType is invalid. Valid options are 'created', 'updated' and 'deleted'`;
        }
        if (args.options.expirationDateTime && !validation_1.validation.isValidISODateTime(args.options.expirationDateTime)) {
            return 'The expirationDateTime is not a valid ISO date string';
        }
        if (args.options.clientState && args.options.clientState.length > 128) {
            return 'The clientState value exceeds the maximum length of 128 characters';
        }
        return true;
    }));
};
module.exports = new GraphSubscriptionAddCommand();
//# sourceMappingURL=subscription-add.js.map