"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GraphChangelogListCommand_instances, _GraphChangelogListCommand_initTelemetry, _GraphChangelogListCommand_initOptions, _GraphChangelogListCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const md_1 = require("../../../../utils/md");
const validation_1 = require("../../../../utils/validation");
const AnonymousCommand_1 = require("../../../base/AnonymousCommand");
const commands_1 = require("../../commands");
const request_1 = require("../../../../request");
const xmldom_1 = require("@xmldom/xmldom");
class GraphChangelogListCommand extends AnonymousCommand_1.default {
    constructor() {
        super();
        _GraphChangelogListCommand_instances.add(this);
        this.allowedVersions = ['beta', 'v1.0'];
        this.allowedChangeTypes = ['Addition', 'Change', 'Deletion', 'Deprecation'];
        this.allowedServices = [
            'Applications', 'Calendar', 'Change notifications', 'Cloud communications',
            'Compliance', 'Cross-device experiences', 'Customer booking', 'Device and app management',
            'Education', 'Files', 'Financials', 'Groups',
            'Identity and access', 'Mail', 'Notes', 'Notifications',
            'People and workplace intelligence', 'Personal contacts', 'Reports', 'Search',
            'Security', 'Sites and lists', 'Tasks and plans', 'Teamwork',
            'To-do tasks', 'Users', 'Workbooks and charts'
        ];
        __classPrivateFieldGet(this, _GraphChangelogListCommand_instances, "m", _GraphChangelogListCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _GraphChangelogListCommand_instances, "m", _GraphChangelogListCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _GraphChangelogListCommand_instances, "m", _GraphChangelogListCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.CHANGELOG_LIST;
    }
    get description() {
        return 'Gets an overview of specific API-level changes in Microsoft Graph v1.0 and beta';
    }
    defaultProperties() {
        return ['category', 'title', 'description'];
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const allowedChangeType = args.options.changeType && this.allowedChangeTypes.find(x => x.toLocaleLowerCase() === args.options.changeType.toLocaleLowerCase());
                const searchParam = args.options.changeType ? `/?filterBy=${allowedChangeType}` : '';
                const requestOptions = {
                    url: `https://developer.microsoft.com/en-us/graph/changelog/rss${searchParam}`,
                    headers: {
                        'accept': 'text/xml',
                        'x-anonymous': 'true'
                    }
                };
                const output = yield request_1.default.get(requestOptions);
                const parser = new xmldom_1.DOMParser();
                const xmlDoc = parser.parseFromString(output.toString(), "text/xml");
                const changelog = this.filterThroughOptions(args.options, this.mapChangelog(xmlDoc, args));
                logger.log(changelog.items);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    filterThroughOptions(options, changelog) {
        let items = changelog.items;
        if (options.services) {
            const allowedServices = this.allowedServices
                .filter(allowedService => options.services.toLocaleLowerCase().split(',').includes(allowedService.toLocaleLowerCase()));
            items = changelog.items.filter(item => allowedServices.includes(item.title));
        }
        if (options.versions) {
            const allowedVersions = this.allowedVersions
                .filter(allowedVersion => options.versions.toLocaleLowerCase().split(',').includes(allowedVersion.toLocaleLowerCase()));
            items = items.filter(item => allowedVersions.includes(item.category));
        }
        if (options.startDate) {
            const startDate = new Date(options.startDate);
            items = items.filter(item => item.pubDate >= startDate);
        }
        if (options.endDate) {
            const endDate = new Date(options.endDate);
            items = items.filter(item => item.pubDate <= endDate);
        }
        // Make sure everything is unique based on the item guid
        items = [...new Map(items.map((item) => [item.guid, item])).values()];
        changelog.items = items.sort((itemA, itemB) => Number(itemB.pubDate) - Number(itemA.pubDate));
        return changelog;
    }
    mapChangelog(xmlDoc, args) {
        const channel = xmlDoc.getElementsByTagName('channel').item(0);
        const changelog = {
            title: channel.getElementsByTagName('title').item(0).textContent,
            description: channel.getElementsByTagName('description').item(0).textContent,
            url: channel.getElementsByTagName('link').item(0).textContent,
            items: []
        };
        Array.from(xmlDoc.getElementsByTagName('item')).forEach((item) => {
            const description = args.options.output === 'text' ?
                md_1.md.md2plain(item.getElementsByTagName('description').item(0).textContent, '') :
                item.getElementsByTagName('description').item(0).textContent;
            changelog.items.push({
                guid: item.getElementsByTagName('guid').item(0).textContent,
                category: item.getElementsByTagName('category').item(1).textContent,
                title: item.getElementsByTagName('title').item(0).textContent,
                description: args.options.output === 'text' ?
                    description.length > 50 ? `${description.substring(0, 47)}...` : description :
                    description,
                pubDate: new Date(item.getElementsByTagName('pubDate').item(0).textContent)
            });
        });
        return changelog;
    }
}
_GraphChangelogListCommand_instances = new WeakSet(), _GraphChangelogListCommand_initTelemetry = function _GraphChangelogListCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            versions: typeof args.options.versions !== 'undefined',
            changeType: typeof args.options.changeType !== 'undefined',
            services: typeof args.options.services !== 'undefined',
            startDate: typeof args.options.startDate !== 'undefined',
            endDate: typeof args.options.endDate !== 'undefined'
        });
    });
}, _GraphChangelogListCommand_initOptions = function _GraphChangelogListCommand_initOptions() {
    this.options.unshift({ option: '-v, --versions [versions]', autocomplete: this.allowedVersions }, { option: "-c, --changeType [changeType]", autocomplete: this.allowedChangeTypes }, { option: "-s, --services [services]", autocomplete: this.allowedServices }, { option: "--startDate [startDate]" }, { option: "--endDate [endDate]" });
}, _GraphChangelogListCommand_initValidators = function _GraphChangelogListCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.versions &&
            args.options.versions.toLocaleLowerCase().split(',').some(x => !this.allowedVersions.map(y => y.toLocaleLowerCase()).includes(x))) {
            return `The verions contains an invalid value. Specify either ${this.allowedVersions.join(', ')} as properties`;
        }
        if (args.options.changeType &&
            !this.allowedChangeTypes.map(x => x.toLocaleLowerCase()).includes(args.options.changeType.toLocaleLowerCase())) {
            return `The change type contain an invalid value. Specify either ${this.allowedChangeTypes.join(', ')} as properties`;
        }
        if (args.options.services &&
            args.options.services.toLocaleLowerCase().split(',').some(x => !this.allowedServices.map(y => y.toLocaleLowerCase()).includes(x))) {
            return `The services contains invalid value. Specify either ${this.allowedServices.join(', ')} as properties`;
        }
        if (args.options.startDate && !validation_1.validation.isValidISODate(args.options.startDate)) {
            return 'The startDate is not a valid ISO date string';
        }
        if (args.options.endDate && !validation_1.validation.isValidISODate(args.options.endDate)) {
            return 'The endDate is not a valid ISO date string';
        }
        if (args.options.endDate && args.options.startDate && new Date(args.options.endDate) < new Date(args.options.startDate)) {
            return 'The endDate should be later than startDate';
        }
        return true;
    }));
};
module.exports = new GraphChangelogListCommand();
//# sourceMappingURL=changelog-list.js.map