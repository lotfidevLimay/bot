"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AdaptiveCardSendCommand_instances, _AdaptiveCardSendCommand_initTelemetry, _AdaptiveCardSendCommand_initOptions, _AdaptiveCardSendCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const request_1 = require("../../../request");
const AnonymousCommand_1 = require("../../base/AnonymousCommand");
const commands_1 = require("../commands");
class AdaptiveCardSendCommand extends AnonymousCommand_1.default {
    constructor() {
        super();
        _AdaptiveCardSendCommand_instances.add(this);
        __classPrivateFieldGet(this, _AdaptiveCardSendCommand_instances, "m", _AdaptiveCardSendCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _AdaptiveCardSendCommand_instances, "m", _AdaptiveCardSendCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _AdaptiveCardSendCommand_instances, "m", _AdaptiveCardSendCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.SEND;
    }
    get description() {
        return 'Sends adaptive card to the specified URL';
    }
    allowUnknownOptions() {
        return true;
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const unknownOptions = this.getUnknownOptions(args.options);
            const unknownOptionNames = Object.getOwnPropertyNames(unknownOptions);
            const card = this.getCard(args, unknownOptionNames, unknownOptions);
            const requestOptions = {
                url: args.options.url,
                headers: {
                    'content-type': 'application/json',
                    'x-anonymous': true
                },
                data: {
                    type: 'message',
                    attachments: [{
                            contentType: 'application/vnd.microsoft.card.adaptive',
                            content: card
                        }]
                },
                responseType: 'json'
            };
            try {
                const res = yield request_1.default.post(requestOptions);
                if (res) {
                    // when sending card to Teams succeeds, the body contains 1 which we
                    // can safely ignore
                    if (typeof res === 'string') {
                        // when sending the webhook to Teams fails, the response is 200
                        // but the body contains a string similar to 'Webhook message delivery
                        // failed with error: Microsoft Teams endpoint returned HTTP error 400
                        // with ContextId MS-CV=Qn6afVIGzEq...' which we should treat as
                        // a failure
                        if (res.indexOf('failed') > -1) {
                            throw res;
                        }
                        logger.log(res);
                    }
                }
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getCard(args, unknownOptionNames, unknownOptions) {
        // use custom card
        if (args.options.card) {
            let card = JSON.parse(args.options.card);
            const cardData = this.getCardData(args, unknownOptionNames, unknownOptions);
            if (cardData) {
                // lazy-load adaptive cards templating SDK
                const ACData = require('adaptivecards-templating');
                const template = new ACData.Template(card);
                // Create a data binding context, and set its $root property to the
                // data object to bind the template to
                const context = {
                    $root: cardData
                };
                // expand the template - this generates the final Adaptive Card
                card = template.expand(context);
            }
            return card;
        }
        // use predefined card
        const card = {
            type: "AdaptiveCard",
            $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
            version: "1.2",
            body: []
        };
        if (args.options.title) {
            card.body.push({
                type: "TextBlock",
                size: "Medium",
                weight: "Bolder",
                text: args.options.title
            });
        }
        if (args.options.imageUrl) {
            card.body.push({
                type: "Image",
                url: args.options.imageUrl,
                size: "Stretch"
            });
        }
        if (args.options.description) {
            card.body.push({
                type: "TextBlock",
                text: args.options.description,
                wrap: true
            });
        }
        if (unknownOptionNames.length > 0) {
            card.body.push({
                type: "FactSet",
                facts: unknownOptionNames.map(o => {
                    return {
                        title: `${o}:`,
                        value: unknownOptions[o]
                    };
                })
            });
        }
        if (args.options.actionUrl) {
            card.actions = [
                {
                    type: "Action.OpenUrl",
                    title: "View",
                    url: args.options.actionUrl
                }
            ];
        }
        return card;
    }
    getCardData(args, unknownOptionNames, unknownOptions) {
        if (args.options.cardData) {
            return JSON.parse(args.options.cardData);
        }
        if (unknownOptionNames.length > 0) {
            return unknownOptions;
        }
        if (!args.options.title &&
            !args.options.description &&
            !args.options.imageUrl &&
            !args.options.actionUrl) {
            return undefined;
        }
        const cardData = {};
        if (args.options.title) {
            cardData.title = args.options.title;
        }
        if (args.options.description) {
            cardData.description = args.options.description;
        }
        if (args.options.imageUrl) {
            cardData.imageUrl = args.options.imageUrl;
        }
        if (args.options.actionUrl) {
            cardData.actionUrl = args.options.actionUrl;
        }
        return cardData;
    }
}
_AdaptiveCardSendCommand_instances = new WeakSet(), _AdaptiveCardSendCommand_initTelemetry = function _AdaptiveCardSendCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            actionUrl: typeof args.options.actionUrl !== 'undefined',
            card: typeof args.options.card !== 'undefined',
            cardData: typeof args.options.cardData !== 'undefined',
            description: typeof args.options.description !== 'undefined',
            imageUrl: typeof args.options.imageUrl !== 'undefined',
            title: typeof args.options.title !== 'undefined'
        });
    });
}, _AdaptiveCardSendCommand_initOptions = function _AdaptiveCardSendCommand_initOptions() {
    this.options.unshift({
        option: '-u, --url <url>'
    }, {
        option: '-t, --title [title]'
    }, {
        option: '-d, --description [description]'
    }, {
        option: '-i, --imageUrl [imageUrl]'
    }, {
        option: '-a, --actionUrl [actionUrl]'
    }, {
        option: '--card [card]'
    }, {
        option: '--cardData [cardData]'
    });
}, _AdaptiveCardSendCommand_initValidators = function _AdaptiveCardSendCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (!args.options.card && !args.options.title) {
            return 'Specify either the title or the card to send';
        }
        if (args.options.card) {
            try {
                JSON.parse(args.options.card);
            }
            catch (e) {
                return `Error while parsing the card: ${e}`;
            }
        }
        if (args.options.cardData) {
            try {
                JSON.parse(args.options.cardData);
            }
            catch (e) {
                return `Error while parsing card data: ${e}`;
            }
        }
        return true;
    }));
};
module.exports = new AdaptiveCardSendCommand();
//# sourceMappingURL=adaptivecard-send.js.map