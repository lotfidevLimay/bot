"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TeamsChatGetCommand_instances, _TeamsChatGetCommand_initTelemetry, _TeamsChatGetCommand_initOptions, _TeamsChatGetCommand_initValidators, _TeamsChatGetCommand_initOptionSets;
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const Auth_1 = require("../../../../Auth");
const request_1 = require("../../../../request");
const accessToken_1 = require("../../../../utils/accessToken");
const validation_1 = require("../../../../utils/validation");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
const chatUtil_1 = require("./chatUtil");
class TeamsChatGetCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _TeamsChatGetCommand_instances.add(this);
        __classPrivateFieldGet(this, _TeamsChatGetCommand_instances, "m", _TeamsChatGetCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _TeamsChatGetCommand_instances, "m", _TeamsChatGetCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _TeamsChatGetCommand_instances, "m", _TeamsChatGetCommand_initValidators).call(this);
        __classPrivateFieldGet(this, _TeamsChatGetCommand_instances, "m", _TeamsChatGetCommand_initOptionSets).call(this);
    }
    get name() {
        return commands_1.default.CHAT_GET;
    }
    get description() {
        return 'Get a Microsoft Teams chat conversation by id, participants or chat name.';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const chatId = yield this.getChatId(args);
                const chat = yield this.getChatDetailsById(chatId);
                logger.log(chat);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getChatId(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.options.id) {
                return args.options.id;
            }
            return args.options.participants
                ? this.getChatIdByParticipants(args.options.participants)
                : this.getChatIdByName(args.options.name);
        });
    }
    getChatDetailsById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = {
                url: `${this.resource}/v1.0/chats/${encodeURIComponent(id)}`,
                headers: {
                    accept: 'application/json;odata.metadata=none'
                },
                responseType: 'json'
            };
            return request_1.default.get(requestOptions);
        });
    }
    getChatIdByParticipants(participantsString) {
        return __awaiter(this, void 0, void 0, function* () {
            const participants = participantsString.trim().toLowerCase().split(',').filter(e => e && e !== '');
            const currentUserEmail = accessToken_1.accessToken.getUserNameFromAccessToken(Auth_1.default.service.accessTokens[this.resource].accessToken).toLowerCase();
            const existingChats = yield chatUtil_1.chatUtil.findExistingChatsByParticipants([currentUserEmail, ...participants]);
            if (!existingChats || existingChats.length === 0) {
                throw new Error('No chat conversation was found with these participants.');
            }
            if (existingChats.length === 1) {
                return existingChats[0].id;
            }
            const disambiguationText = existingChats.map(c => {
                return `- ${c.id}${c.topic && ' - '}${c.topic} - ${c.createdDateTime && new Date(c.createdDateTime).toLocaleString()}`;
            }).join(os.EOL);
            throw new Error(`Multiple chat conversations with these participants found. Please disambiguate:${os.EOL}${disambiguationText}`);
        });
    }
    getChatIdByName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingChats = yield chatUtil_1.chatUtil.findExistingGroupChatsByName(name);
            if (!existingChats || existingChats.length === 0) {
                throw new Error('No chat conversation was found with this name.');
            }
            if (existingChats.length === 1) {
                return existingChats[0].id;
            }
            const disambiguationText = existingChats.map(c => {
                const memberstring = c.members.map(m => m.email).join(', ');
                return `- ${c.id} - ${c.createdDateTime && new Date(c.createdDateTime).toLocaleString()} - ${memberstring}`;
            }).join(os.EOL);
            throw new Error(`Multiple chat conversations with this name found. Please disambiguate:${os.EOL}${disambiguationText}`);
        });
    }
}
_TeamsChatGetCommand_instances = new WeakSet(), _TeamsChatGetCommand_initTelemetry = function _TeamsChatGetCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            id: typeof args.options.id !== 'undefined',
            participants: typeof args.options.participants !== 'undefined',
            name: typeof args.options.name !== 'undefined'
        });
    });
}, _TeamsChatGetCommand_initOptions = function _TeamsChatGetCommand_initOptions() {
    this.options.unshift({
        option: '-i, --id [id]'
    }, {
        option: '-p, --participants [participants]'
    }, {
        option: '-n, --name [name]'
    });
}, _TeamsChatGetCommand_initValidators = function _TeamsChatGetCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.id && !validation_1.validation.isValidTeamsChatId(args.options.id)) {
            return `${args.options.id} is not a valid Teams ChatId.`;
        }
        if (args.options.participants) {
            const participants = args.options.participants.trim().toLowerCase().split(',').filter(e => e && e !== '');
            if (!participants || participants.length === 0 || participants.some(e => !validation_1.validation.isValidUserPrincipalName(e))) {
                return `${args.options.participants} contains one or more invalid email addresses.`;
            }
        }
        return true;
    }));
}, _TeamsChatGetCommand_initOptionSets = function _TeamsChatGetCommand_initOptionSets() {
    this.optionSets.push(['id', 'participants', 'name']);
};
module.exports = new TeamsChatGetCommand();
//# sourceMappingURL=chat-get.js.map