"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TeamsChatMessageSendCommand_instances, _TeamsChatMessageSendCommand_initTelemetry, _TeamsChatMessageSendCommand_initOptions, _TeamsChatMessageSendCommand_initValidators, _TeamsChatMessageSendCommand_initOptionSets;
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const Auth_1 = require("../../../../Auth");
const request_1 = require("../../../../request");
const accessToken_1 = require("../../../../utils/accessToken");
const validation_1 = require("../../../../utils/validation");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
const chatUtil_1 = require("./chatUtil");
class TeamsChatMessageSendCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _TeamsChatMessageSendCommand_instances.add(this);
        __classPrivateFieldGet(this, _TeamsChatMessageSendCommand_instances, "m", _TeamsChatMessageSendCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _TeamsChatMessageSendCommand_instances, "m", _TeamsChatMessageSendCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _TeamsChatMessageSendCommand_instances, "m", _TeamsChatMessageSendCommand_initValidators).call(this);
        __classPrivateFieldGet(this, _TeamsChatMessageSendCommand_instances, "m", _TeamsChatMessageSendCommand_initOptionSets).call(this);
    }
    get name() {
        return commands_1.default.CHAT_MESSAGE_SEND;
    }
    get description() {
        return 'Sends a chat message to a Microsoft Teams chat conversation.';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const chatId = yield this.getChatId(logger, args);
                yield this.sendChatMessage(chatId, args);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    getChatId(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.options.chatId) {
                return args.options.chatId;
            }
            return args.options.userEmails
                ? this.ensureChatIdByUserEmails(args.options.userEmails)
                : this.getChatIdByName(args.options.chatName);
        });
    }
    ensureChatIdByUserEmails(userEmailsOption) {
        return __awaiter(this, void 0, void 0, function* () {
            const userEmails = userEmailsOption.trim().toLowerCase().split(',').filter(e => e && e !== '');
            const currentUserEmail = accessToken_1.accessToken.getUserNameFromAccessToken(Auth_1.default.service.accessTokens[this.resource].accessToken).toLowerCase();
            const existingChats = yield chatUtil_1.chatUtil.findExistingChatsByParticipants([currentUserEmail, ...userEmails]);
            if (!existingChats || existingChats.length === 0) {
                const chat = yield this.createConversation([currentUserEmail, ...userEmails]);
                return chat.id;
            }
            if (existingChats.length === 1) {
                return existingChats[0].id;
            }
            const disambiguationText = existingChats.map(c => {
                return `- ${c.id}${c.topic && ' - '}${c.topic} - ${c.createdDateTime && new Date(c.createdDateTime).toLocaleString()}`;
            }).join(os.EOL);
            throw new Error(`Multiple chat conversations with this name found. Please disambiguate:${os.EOL}${disambiguationText}`);
        });
    }
    getChatIdByName(chatName) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingChats = yield chatUtil_1.chatUtil.findExistingGroupChatsByName(chatName);
            if (!existingChats || existingChats.length === 0) {
                throw new Error('No chat conversation was found with this name.');
            }
            if (existingChats.length === 1) {
                return existingChats[0].id;
            }
            const disambiguationText = existingChats.map(c => {
                const memberstring = c.members.map(m => m.email).join(', ');
                return `- ${c.id} - ${c.createdDateTime && new Date(c.createdDateTime).toLocaleString()} - ${memberstring}`;
            }).join(os.EOL);
            throw new Error(`Multiple chat conversations with this name found. Please disambiguate:${os.EOL}${disambiguationText}`);
        });
    }
    // This Microsoft Graph API request throws an intermittent 404 exception, saying that it cannot find the principal.
    // The same behavior occurs when creating the conversation through the Graph Explorer.
    // It seems to happen when the userEmail casing does not match the casing of the actual UPN. 
    // When the first request throws an error, the second request does succeed. 
    // Therefore a retry-mechanism is implemented here. 
    createConversation(memberEmails, retried = 0) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const jsonBody = {
                    chatType: memberEmails.length > 2 ? 'group' : 'oneOnOne',
                    members: memberEmails.map(email => {
                        return {
                            '@odata.type': '#microsoft.graph.aadUserConversationMember',
                            roles: ['owner'],
                            'user@odata.bind': `https://graph.microsoft.com/v1.0/users/${email}`
                        };
                    })
                };
                const requestOptions = {
                    url: `${this.resource}/v1.0/chats`,
                    headers: {
                        accept: 'application/json;odata.metadata=none',
                        'content-type': 'application/json;odata=nometadata'
                    },
                    responseType: 'json',
                    data: jsonBody
                };
                return yield request_1.default.post(requestOptions);
            }
            catch (err) {
                if (((_a = err.message) === null || _a === void 0 ? void 0 : _a.indexOf('404')) > -1 && retried < 4) {
                    return yield this.createConversation(memberEmails, retried + 1);
                }
                throw err;
            }
        });
    }
    sendChatMessage(chatId, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestOptions = {
                url: `${this.resource}/v1.0/chats/${chatId}/messages`,
                headers: {
                    accept: 'application/json;odata.metadata=none',
                    'content-type': 'application/json;odata=nometadata'
                },
                responseType: 'json',
                data: {
                    body: {
                        content: args.options.message
                    }
                }
            };
            yield request_1.default.post(requestOptions);
        });
    }
}
_TeamsChatMessageSendCommand_instances = new WeakSet(), _TeamsChatMessageSendCommand_initTelemetry = function _TeamsChatMessageSendCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            chatId: typeof args.options.chatId !== 'undefined',
            userEmails: typeof args.options.userEmails !== 'undefined',
            chatName: typeof args.options.chatName !== 'undefined'
        });
    });
}, _TeamsChatMessageSendCommand_initOptions = function _TeamsChatMessageSendCommand_initOptions() {
    this.options.unshift({
        option: '--chatId [chatId]'
    }, {
        option: '-e, --userEmails [userEmails]'
    }, {
        option: '--chatName [chatName]'
    }, {
        option: '-m, --message <message>'
    });
}, _TeamsChatMessageSendCommand_initValidators = function _TeamsChatMessageSendCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.chatId && !validation_1.validation.isValidTeamsChatId(args.options.chatId)) {
            return `${args.options.chatId} is not a valid Teams ChatId.`;
        }
        if (args.options.userEmails) {
            const userEmails = args.options.userEmails.trim().toLowerCase().split(',').filter(e => e && e !== '');
            if (!userEmails || userEmails.length === 0 || userEmails.some(e => !validation_1.validation.isValidUserPrincipalName(e))) {
                return `${args.options.userEmails} contains one or more invalid email addresses.`;
            }
        }
        return true;
    }));
}, _TeamsChatMessageSendCommand_initOptionSets = function _TeamsChatMessageSendCommand_initOptionSets() {
    this.optionSets.push(['chatId', 'userEmails', 'chatName']);
};
module.exports = new TeamsChatMessageSendCommand();
//# sourceMappingURL=chat-message-send.js.map