"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PlannerPlanAddCommand_instances, _PlannerPlanAddCommand_initTelemetry, _PlannerPlanAddCommand_initOptions, _PlannerPlanAddCommand_initValidators, _PlannerPlanAddCommand_initOptionSets;
Object.defineProperty(exports, "__esModule", { value: true });
const Auth_1 = require("../../../../Auth");
const request_1 = require("../../../../request");
const aadGroup_1 = require("../../../../utils/aadGroup");
const accessToken_1 = require("../../../../utils/accessToken");
const formatting_1 = require("../../../../utils/formatting");
const validation_1 = require("../../../../utils/validation");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
class PlannerPlanAddCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _PlannerPlanAddCommand_instances.add(this);
        __classPrivateFieldGet(this, _PlannerPlanAddCommand_instances, "m", _PlannerPlanAddCommand_initTelemetry).call(this);
        __classPrivateFieldGet(this, _PlannerPlanAddCommand_instances, "m", _PlannerPlanAddCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _PlannerPlanAddCommand_instances, "m", _PlannerPlanAddCommand_initValidators).call(this);
        __classPrivateFieldGet(this, _PlannerPlanAddCommand_instances, "m", _PlannerPlanAddCommand_initOptionSets).call(this);
    }
    get name() {
        return commands_1.default.PLAN_ADD;
    }
    get description() {
        return 'Adds a new Microsoft Planner plan';
    }
    defaultProperties() {
        return ['id', 'title', 'createdDateTime', 'owner'];
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (accessToken_1.accessToken.isAppOnlyAccessToken(Auth_1.default.service.accessTokens[this.resource].accessToken)) {
                this.handleError('This command does not support application permissions.');
                return;
            }
            try {
                const groupId = yield this.getGroupId(args);
                const requestOptions = {
                    url: `${this.resource}/v1.0/planner/plans`,
                    headers: {
                        'accept': 'application/json;odata.metadata=none'
                    },
                    responseType: 'json',
                    data: {
                        owner: groupId,
                        title: args.options.title
                    }
                };
                const newPlan = yield request_1.default.post(requestOptions);
                const result = yield this.updatePlanDetails(args.options, newPlan);
                logger.log(result);
            }
            catch (err) {
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    updatePlanDetails(options, newPlan) {
        const planId = newPlan.id;
        if (!options.shareWithUserIds && !options.shareWithUserNames) {
            return Promise.resolve(newPlan);
        }
        return Promise
            .all([this.generateSharedWith(options), this.getPlanDetailsEtag(planId)])
            .then(resArray => {
            const sharedWith = resArray[0];
            const etag = resArray[1];
            const requestOptionsPlanDetails = {
                url: `${this.resource}/v1.0/planner/plans/${planId}/details`,
                headers: {
                    'accept': 'application/json;odata.metadata=none',
                    'If-Match': etag,
                    'Prefer': 'return=representation'
                },
                responseType: 'json',
                data: {
                    sharedWith: sharedWith
                }
            };
            return request_1.default.patch(requestOptionsPlanDetails);
        })
            .then(planDetails => {
            return Object.assign(Object.assign({}, newPlan), planDetails);
        });
    }
    getPlanDetailsEtag(planId) {
        const requestOptions = {
            url: `${this.resource}/v1.0/planner/plans/${planId}/details`,
            headers: {
                accept: 'application/json'
            },
            responseType: 'json'
        };
        return request_1.default
            .get(requestOptions)
            .then((response) => response['@odata.etag']);
    }
    generateSharedWith(options) {
        const sharedWith = {};
        return this
            .getUserIds(options)
            .then((userIds) => {
            userIds.map(x => sharedWith[x] = true);
            return Promise.resolve(sharedWith);
        });
    }
    getUserIds(options) {
        if (options.shareWithUserIds) {
            return Promise.resolve(options.shareWithUserIds.split(','));
        }
        // Hitting this section means assignedToUserNames won't be undefined
        const userNames = options.shareWithUserNames;
        const userArr = userNames.split(',').map(o => o.trim());
        const promises = userArr.map(user => {
            const requestOptions = {
                url: `${this.resource}/v1.0/users?$filter=userPrincipalName eq '${formatting_1.formatting.encodeQueryParameter(user)}'&$select=id,userPrincipalName`,
                headers: {
                    'content-type': 'application/json'
                },
                responseType: 'json'
            };
            return request_1.default.get(requestOptions);
        });
        return Promise
            .all(promises)
            .then((usersRes) => {
            const userUpns = usersRes.map(res => { var _a; return (_a = res.value[0]) === null || _a === void 0 ? void 0 : _a.userPrincipalName; });
            const userIds = usersRes.map(res => { var _a; return (_a = res.value[0]) === null || _a === void 0 ? void 0 : _a.id; });
            // Find the members where no graph response was found
            const invalidUsers = userArr.filter(user => !userUpns.some((upn) => (upn === null || upn === void 0 ? void 0 : upn.toLowerCase()) === user.toLowerCase()));
            if (invalidUsers && invalidUsers.length > 0) {
                return Promise.reject(`Cannot proceed with planner plan creation. The following users provided are invalid : ${invalidUsers.join(',')}`);
            }
            return Promise.resolve(userIds);
        });
    }
    getGroupId(args) {
        if (args.options.ownerGroupId) {
            return Promise.resolve(args.options.ownerGroupId);
        }
        return aadGroup_1.aadGroup
            .getGroupByDisplayName(args.options.ownerGroupName)
            .then(group => group.id);
    }
}
_PlannerPlanAddCommand_instances = new WeakSet(), _PlannerPlanAddCommand_initTelemetry = function _PlannerPlanAddCommand_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            ownerGroupId: typeof args.options.ownerGroupId !== 'undefined',
            ownerGroupName: typeof args.options.ownerGroupName !== 'undefined',
            shareWithUserIds: typeof args.options.shareWithUserIds !== 'undefined',
            shareWithUserNames: typeof args.options.shareWithUserNames !== 'undefined'
        });
    });
}, _PlannerPlanAddCommand_initOptions = function _PlannerPlanAddCommand_initOptions() {
    this.options.unshift({
        option: '-t, --title <title>'
    }, {
        option: "--ownerGroupId [ownerGroupId]"
    }, {
        option: "--ownerGroupName [ownerGroupName]"
    }, {
        option: '--shareWithUserIds [shareWithUserIds]'
    }, {
        option: '--shareWithUserNames [shareWithUserNames]'
    });
}, _PlannerPlanAddCommand_initValidators = function _PlannerPlanAddCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (args.options.ownerGroupId && !validation_1.validation.isValidGuid(args.options.ownerGroupId)) {
            return `${args.options.ownerGroupId} is not a valid GUID`;
        }
        if (args.options.shareWithUserIds && args.options.shareWithUserNames) {
            return 'Specify either shareWithUserIds or shareWithUserNames but not both';
        }
        if (args.options.shareWithUserIds && !validation_1.validation.isValidGuidArray(args.options.shareWithUserIds.split(','))) {
            return 'shareWithUserIds contains invalid GUID';
        }
        return true;
    }));
}, _PlannerPlanAddCommand_initOptionSets = function _PlannerPlanAddCommand_initOptionSets() {
    this.optionSets.push(['ownerGroupId', 'ownerGroupName']);
};
module.exports = new PlannerPlanAddCommand();
//# sourceMappingURL=plan-add.js.map