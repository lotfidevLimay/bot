"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PaSolutionReferenceAddCommand_instances, _PaSolutionReferenceAddCommand_initOptions, _PaSolutionReferenceAddCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const Command_1 = require("../../../../Command");
const AnonymousCommand_1 = require("../../../base/AnonymousCommand");
const cds_project_mutator_1 = require("../../cds-project-mutator");
const commands_1 = require("../../commands");
/*
 * Logic extracted from bolt.module.solution.dll
 * Version: 1.0.6
 * Class: bolt.module.solution.verbs.SolutionAddReferenceVerb
 */
class PaSolutionReferenceAddCommand extends AnonymousCommand_1.default {
    constructor() {
        super();
        _PaSolutionReferenceAddCommand_instances.add(this);
        __classPrivateFieldGet(this, _PaSolutionReferenceAddCommand_instances, "m", _PaSolutionReferenceAddCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _PaSolutionReferenceAddCommand_instances, "m", _PaSolutionReferenceAddCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.SOLUTION_REFERENCE_ADD;
    }
    get description() {
        return 'Adds a project reference to the solution in the current directory';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const referencedProjectFilePath = this.getSupportedProjectFiles(args.options.path)[0];
                const relativeReferencedProjectFilePath = path.relative(process.cwd(), referencedProjectFilePath);
                const cdsProjectFilePath = this.getCdsProjectFile(process.cwd())[0];
                const cdsProjectFileContent = fs.readFileSync(cdsProjectFilePath, 'utf8');
                const cdsProjectMutator = new cds_project_mutator_1.default(cdsProjectFileContent);
                cdsProjectMutator.addProjectReference(relativeReferencedProjectFilePath);
                fs.writeFileSync(cdsProjectFilePath, cdsProjectMutator.cdsProjectDocument);
            }
            catch (err) {
                throw new Command_1.CommandError(err);
            }
        });
    }
    getCdsProjectFile(rootPath) {
        return fs.readdirSync(rootPath)
            .filter(fn => path.extname(fn).toLowerCase() === '.cdsproj')
            .map(entry => path.join(rootPath, entry));
    }
    getSupportedProjectFiles(rootPath) {
        return fs.readdirSync(rootPath).filter(fn => {
            const ext = path.extname(fn).toLowerCase();
            return ext === '.pcfproj' || ext === '.csproj';
        }).map(entry => path.join(rootPath, entry));
    }
}
_PaSolutionReferenceAddCommand_instances = new WeakSet(), _PaSolutionReferenceAddCommand_initOptions = function _PaSolutionReferenceAddCommand_initOptions() {
    this.options.unshift({
        option: '-p, --path <path>'
    });
}, _PaSolutionReferenceAddCommand_initValidators = function _PaSolutionReferenceAddCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        const existingCdsProjects = this.getCdsProjectFile(process.cwd());
        if (existingCdsProjects.length === 0) {
            return 'CDS solution project file with extension cdsproj was not found in the current directory.';
        }
        if (existingCdsProjects.length > 1) {
            return 'Multiple CDS solution project files with extension cdsproj were found in the current directory.';
        }
        if (!fs.existsSync(args.options.path)) {
            return `Path ${args.options.path} is not a valid path.`;
        }
        const existingSupportedProjects = this.getSupportedProjectFiles(args.options.path);
        if (existingSupportedProjects.length === 0) {
            return `No supported project type found in path ${args.options.path}.`;
        }
        if (existingSupportedProjects.length !== 1) {
            return `More than one supported project type found in path ${args.options.path}.`;
        }
        const cdsProjectName = path.parse(path.basename(existingCdsProjects[0])).name;
        const pcfProjectName = path.parse(path.basename(existingSupportedProjects[0])).name;
        if (cdsProjectName === pcfProjectName) {
            return `Not able to add reference to a project with same name as CDS project with name: ${pcfProjectName}.`;
        }
        return true;
    }));
};
module.exports = new PaSolutionReferenceAddCommand();
//# sourceMappingURL=solution-reference-add.js.map