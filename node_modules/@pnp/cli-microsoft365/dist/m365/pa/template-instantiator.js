"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
/*
 * Logic extracted from bolt.cli.dll
 * Version: 1.0.6
 * Class: bolt.cli.TemplateInstantiator
 */
class TemplateInstantiator {
    static instantiate(logger, sourcePath, destinationPath, recursive, variables, verbose) {
        TemplateInstantiator.mkdirSyncIfNotExists(logger, destinationPath, verbose);
        this.getFiles(sourcePath, recursive).forEach(file => {
            const filePath = path.relative(sourcePath, path.dirname(file));
            const destinationFilePath = path.join(destinationPath, filePath);
            TemplateInstantiator.mkdirSyncIfNotExists(logger, destinationFilePath, verbose);
            this.instantiateTemplate(file, destinationFilePath, variables);
        });
    }
    static mkdirSyncIfNotExists(logger, destinationPath, verbose) {
        if (!fs.existsSync(destinationPath)) {
            if (verbose) {
                logger.logToStderr(`Create directory: ${destinationPath}`);
            }
            fs.mkdirSync(destinationPath);
        }
    }
    static instantiateTemplate(templatePath, destinationPath, variables) {
        let isTemplateFile = false;
        let fileName = path.basename(templatePath);
        if (fileName.toLowerCase().startsWith('template_')) {
            isTemplateFile = true;
            fileName = fileName.substring('template_'.length, fileName.length);
        }
        for (const variable in variables) {
            fileName = fileName.replace(variable, variables[variable]);
        }
        const destinationFilePath = path.join(destinationPath, fileName);
        if (!isTemplateFile) {
            fs.copyFileSync(templatePath, destinationFilePath);
        }
        else {
            let fileContent = fs.readFileSync(templatePath, 'utf8');
            for (const variable in variables) {
                fileContent = fileContent.replace(new RegExp(variable.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), 'g'), variables[variable]);
            }
            fs.writeFileSync(destinationFilePath, fileContent, 'utf8');
        }
    }
    static getFiles(folderPath, recursive) {
        const entryPaths = fs.readdirSync(folderPath).map(entry => path.join(folderPath, entry));
        const filePaths = entryPaths.filter(entryPath => fs.statSync(entryPath).isFile());
        const dirPaths = entryPaths.filter(entryPath => !filePaths.includes(entryPath));
        const dirFiles = recursive ? dirPaths.reduce((prev, curr) => prev.concat(this.getFiles(curr, recursive)), []) : [];
        return [...filePaths, ...dirFiles];
    }
}
exports.default = TemplateInstantiator;
//# sourceMappingURL=template-instantiator.js.map