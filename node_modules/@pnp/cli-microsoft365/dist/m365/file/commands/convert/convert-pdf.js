"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FileConvertPdfCommand_instances, _FileConvertPdfCommand_initOptions, _FileConvertPdfCommand_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const url = require("url");
const uuid_1 = require("uuid");
const Auth_1 = require("../../../../Auth");
const Command_1 = require("../../../../Command");
const request_1 = require("../../../../request");
const GraphCommand_1 = require("../../../base/GraphCommand");
const commands_1 = require("../../commands");
class FileConvertPdfCommand extends GraphCommand_1.default {
    constructor() {
        super();
        _FileConvertPdfCommand_instances.add(this);
        __classPrivateFieldGet(this, _FileConvertPdfCommand_instances, "m", _FileConvertPdfCommand_initOptions).call(this);
        __classPrivateFieldGet(this, _FileConvertPdfCommand_instances, "m", _FileConvertPdfCommand_initValidators).call(this);
    }
    get name() {
        return commands_1.default.CONVERT_PDF;
    }
    get description() {
        return 'Converts the specified file to PDF using Microsoft Graph';
    }
    commandAction(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let sourceFileUrl = '';
            // path to the local file that contains the PDF-converted source file
            let localTargetFilePath = args.options.targetFile;
            let sourceIsLocalFile = true;
            let targetIsLocalFile = true;
            let error;
            const isAppOnlyAuth = Auth_1.Auth.isAppOnlyAuth(Auth_1.default.service.accessTokens[Auth_1.default.defaultResource].accessToken);
            if (typeof isAppOnlyAuth === 'undefined') {
                throw 'Unable to determine authentication type';
            }
            if (args.options.sourceFile.toLowerCase().startsWith('https://')) {
                sourceIsLocalFile = false;
            }
            if (args.options.targetFile.toLowerCase().startsWith('https://')) {
                localTargetFilePath = path.join(os.tmpdir(), (0, uuid_1.v4)());
                targetIsLocalFile = false;
                if (this.debug) {
                    logger.logToStderr(`Target set to a URL. Will store the temporary converted file at ${localTargetFilePath}`);
                }
            }
            try {
                try {
                    sourceFileUrl = yield this.getSourceFileUrl(logger, args, isAppOnlyAuth);
                    const graphFileUrl = yield this.getGraphFileUrl(logger, sourceFileUrl, this.sourceFileGraphUrl);
                    const fileResponse = yield this.convertFile(logger, graphFileUrl);
                    yield this.writeFileToDisk(logger, fileResponse, localTargetFilePath);
                    yield this.uploadConvertedFileIfNecessary(logger, targetIsLocalFile, localTargetFilePath, args.options.targetFile);
                }
                catch (err) {
                    // catch the error from any of the previous promises so that we can
                    // clean up resources in case something went wrong
                    // if this.deleteRemoteSourceFileIfNecessary fails, it won't be caught
                    // here, but rather at the end
                    error = err;
                }
                yield this.deleteRemoteSourceFileIfNecessary(logger, sourceIsLocalFile, sourceFileUrl);
                // if the target was a remote file, delete the local temp file
                if (!targetIsLocalFile) {
                    if (this.verbose) {
                        logger.logToStderr(`Deleting the temporary PDF file at ${localTargetFilePath}...`);
                    }
                    try {
                        fs.unlinkSync(localTargetFilePath);
                    }
                    catch (e) {
                        throw e;
                    }
                }
                else {
                    if (this.debug) {
                        logger.logToStderr(`Target is a local path. Not deleting`);
                    }
                }
                if (error) {
                    this.handleRejectedODataJsonPromise(error);
                }
            }
            catch (err) {
                if (err instanceof Command_1.CommandError) {
                    throw err;
                }
                this.handleRejectedODataJsonPromise(err);
            }
        });
    }
    /**
     * Returns web URL of the file to convert to PDF. If the user specified a URL
     * in command's options, returns the specified URL. If the user specified
     * a local file, it will upload the file and return its web URL. If CLI
     * is authenticated as app-only, uploads the file to the default document
     * library in the root site. If the CLI is authenticated as user, uploads the
     * file to the user's OneDrive for Business
     * @param logger Logger instance
     * @param args Command args
     * @param isAppOnlyAuth True if CLI is authenticated in app-only mode
     * @returns Web URL of the file to upload
     */
    getSourceFileUrl(logger, args, isAppOnlyAuth) {
        if (args.options.sourceFile.toLowerCase().startsWith('https://')) {
            return Promise.resolve(args.options.sourceFile);
        }
        if (this.verbose) {
            logger.logToStderr('Uploading local file temporarily for conversion...');
        }
        const driveUrl = `${this.resource}/v1.0/${isAppOnlyAuth ? 'drive/root' : 'me/drive/root'}`;
        // we need the original file extension because otherwise Graph won't be able
        // to convert the file to PDF
        this.sourceFileGraphUrl = `${driveUrl}:/${(0, uuid_1.v4)()}${path.extname(args.options.sourceFile)}`;
        if (this.debug) {
            logger.logToStderr(`Source is a local file. Uploading to ${this.sourceFileGraphUrl}...`);
        }
        return this.uploadFile(args.options.sourceFile, this.sourceFileGraphUrl);
    }
    /**
     * Uploads the specified local file to a document library using Microsoft Graph
     * @param localFilePath Path to the local file to upload
     * @param targetGraphFileUrl Graph drive item URL of the file to upload
     * @returns Absolute URL of the uploaded file
     */
    uploadFile(localFilePath, targetGraphFileUrl) {
        const requestOptions = {
            url: `${targetGraphFileUrl}:/createUploadSession`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default
            .post(requestOptions)
            .then((res) => {
            const fileContents = fs.readFileSync(localFilePath);
            const requestOptions = {
                url: res.uploadUrl,
                headers: {
                    'x-anonymous': true,
                    'accept': 'application/json;odata.metadata=none',
                    'Content-Length': fileContents.length,
                    'Content-Range': `bytes 0-${fileContents.length - 1}/${fileContents.length}`
                },
                data: fileContents,
                responseType: 'json'
            };
            return request_1.default.put(requestOptions);
        })
            .then((res) => res.webUrl);
    }
    /**
     * Gets Graph's drive item URL for the specified file. If the user specified
     * a local file to convert to PDF, returns the URL resolved while uploading
     * the file
     *
     * Example:
     *
     * fileWebUrl:
     * https://contoso.sharepoint.com/sites/Contoso/site/Shared%20Documents/file.docx
     *
     * returns:
     * https://graph.microsoft.com/v1.0/sites/contoso.sharepoint.com,9d1b2174-9906-43ec-8c9e-f8589de047af,f60c833e-71ce-4a5a-b90e-2a7fdb718397/drives/b!k6NJ6ubjYEehsullOeFTcuYME3w1S8xHoHziURdWlu-DWrqz1yBLQI7E7_4TN6fL/root:/file.docx
     *
     * @param logger Logger instance
     * @param fileWebUrl Web URL of the file for which to get drive item URL
     * @param fileGraphUrl If set, will return this URL without further action
     * @returns Graph's drive item URL for the specified file
     */
    getGraphFileUrl(logger, fileWebUrl, fileGraphUrl) {
        if (this.debug) {
            logger.logToStderr(`Resolving Graph drive item URL for ${fileWebUrl}`);
        }
        if (fileGraphUrl) {
            if (this.debug) {
                logger.logToStderr(`Returning previously resolved Graph drive item URL ${fileGraphUrl}`);
            }
            return Promise.resolve(fileGraphUrl);
        }
        const _url = url.parse(fileWebUrl);
        let siteId = '';
        let driveRelativeFileUrl = '';
        return this
            .getGraphSiteInfoFromFullUrl(_url.host, _url.path)
            .then(siteInfo => {
            siteId = siteInfo.id;
            let siteRelativeFileUrl = _url.path.replace(siteInfo.serverRelativeUrl, '');
            // normalize site-relative URLs for root site collections and root sites
            if (!siteRelativeFileUrl.startsWith('/')) {
                siteRelativeFileUrl = '/' + siteRelativeFileUrl;
            }
            const siteRelativeFileUrlChunks = siteRelativeFileUrl.split('/');
            driveRelativeFileUrl = `/${siteRelativeFileUrlChunks.slice(2).join('/')}`;
            // chunk 0 is empty because the URL starts with /
            return this.getDriveId(logger, siteId, siteRelativeFileUrlChunks[1]);
        })
            .then(driveId => {
            const graphUrl = `${this.resource}/v1.0/sites/${siteId}/drives/${driveId}/root:${driveRelativeFileUrl}`;
            if (this.debug) {
                logger.logToStderr(`Resolved URL ${graphUrl}`);
            }
            return graphUrl;
        });
    }
    /**
     * Retrieves the Graph ID and server-relative URL of the specified (sub)site.
     * Automatically detects which path chunks correspond to (sub)site.
     * @param hostName SharePoint host name, eg. contoso.sharepoint.com
     * @param urlPath Server-relative file URL, eg. /sites/site/docs/file1.aspx
     * @returns ID and server-relative URL of the site denoted by urlPath
     */
    getGraphSiteInfoFromFullUrl(hostName, urlPath) {
        const siteId = '';
        const urlChunks = urlPath.split('/');
        return new Promise((resolve, reject) => {
            this.getGraphSiteInfo(hostName, urlChunks, 0, siteId, resolve, reject);
        });
    }
    /**
     * Retrieves Graph site ID and server-relative URL of the site specified
     * using chunks from the URL path. Method is being called recursively as long
     * as it can successfully retrieve the site. When retrieving site fails, method
     * will return the last resolved site ID. If no site ID has been retrieved
     * (method fails on the first execution), it will call the reject callback.
     * @param hostName SharePoint host name, eg. contoso.sharepoint.com
     * @param urlChunks Array of chunks from server-relative URL, eg. ['sites', 'site', 'subsite', 'docs', 'file1.aspx']
     * @param currentChunk Current chunk that's being tested, eg. sites
     * @param lastSiteId Last correctly resolved Graph site ID
     * @param resolve Callback method to call when resolving site info succeeded
     * @param reject Callback method to call when resolving site info failed
     * @returns Graph site ID and server-relative URL of the site specified through chunks
     */
    getGraphSiteInfo(hostName, urlChunks, currentChunk, lastSiteId, resolve, reject) {
        let currentPath = urlChunks.slice(0, currentChunk + 1).join('/');
        if (currentPath.endsWith('/sites') ||
            currentPath.endsWith('/teams') ||
            currentPath.endsWith('/personal')) {
            return this.getGraphSiteInfo(hostName, urlChunks, ++currentChunk, '', resolve, reject);
        }
        if (!currentPath.startsWith('/')) {
            currentPath = '/' + currentPath;
        }
        const requestOptions = {
            url: `${this.resource}/v1.0/sites/${hostName}:${currentPath}?$select=id`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        request_1.default
            .get(requestOptions)
            .then((res) => {
            this.getGraphSiteInfo(hostName, urlChunks, ++currentChunk, res.id, resolve, reject);
        }, err => {
            if (lastSiteId) {
                let serverRelativeUrl = `${urlChunks.slice(0, currentChunk).join('/')}`;
                if (!serverRelativeUrl.startsWith('/')) {
                    serverRelativeUrl = '/' + serverRelativeUrl;
                }
                resolve({
                    id: lastSiteId,
                    serverRelativeUrl: serverRelativeUrl
                });
            }
            else {
                reject(err);
            }
        });
    }
    /**
     * Returns the Graph drive ID of the specified document library
     * @param graphSiteId Graph ID of the site where the document library is located
     * @param siteRelativeListUrl Server-relative URL of the document library, eg. /sites/site/Documents
     * @returns Graph drive ID of the specified document library
     */
    getDriveId(logger, graphSiteId, siteRelativeListUrl) {
        const requestOptions = {
            url: `${this.resource}/v1.0/sites/${graphSiteId}/drives?$select=webUrl,id`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'json'
        };
        return request_1.default
            .get(requestOptions)
            .then((res) => {
            if (this.debug) {
                logger.logToStderr(`Searching for drive with a URL ending with /${siteRelativeListUrl}...`);
            }
            const drive = res.value.find(d => d.webUrl.endsWith(`/${siteRelativeListUrl}`));
            if (!drive) {
                return Promise.reject('Drive not found');
            }
            return Promise.resolve(drive.id);
        });
    }
    /**
     * Requests conversion of a file to PDF using Microsoft Graph
     * @param logger Logger instance
     * @param graphFileUrl Graph drive item URL of the file to convert to PDF
     * @returns Response object with a URL in the Location header that contains
     * the file converted to PDF. The URL must be called anonymously
     */
    convertFile(logger, graphFileUrl) {
        if (this.verbose) {
            logger.logToStderr('Converting file...');
        }
        const requestOptions = {
            url: `${graphFileUrl}:/content?format=pdf`,
            headers: {
                accept: 'application/json;odata.metadata=none'
            },
            responseType: 'stream'
        };
        return request_1.default.get(requestOptions);
    }
    /**
     * Writes the contents of the specified file stream to a local file
     * @param logger Logger instance
     * @param fileResponse Response with stream file contents
     * @param localFilePath Local file path where to store the file
     */
    writeFileToDisk(logger, fileResponse, localFilePath) {
        if (this.verbose) {
            logger.logToStderr(`Writing converted PDF file to ${localFilePath}...`);
        }
        return new Promise((resolve, reject) => {
            // write the downloaded file to disk
            const writer = fs.createWriteStream(localFilePath);
            fileResponse.data.pipe(writer);
            writer.on('error', err => {
                reject(err);
            });
            writer.on('close', () => {
                resolve();
            });
        });
    }
    /**
     * If the user specified a URL as the targetFile, uploads the converted PDF
     * file to the specified location. If targetFile is a local path, doesn't do
     * anything.
     * @param logger Logger instance
     * @param targetIsLocalFile Boolean that denotes if user specified as the target location a local path
     * @param localFilePath Local file path to where the file to be uploaded is located
     * @param targetFileUrl Web URL of the file to upload
     */
    uploadConvertedFileIfNecessary(logger, targetIsLocalFile, localFilePath, targetFileUrl) {
        // if the target was a local path, we're done.
        // Otherwise, upload the file to the specified URL
        if (targetIsLocalFile) {
            if (this.debug) {
                logger.logToStderr('Specified target is a local file. Not uploading.');
            }
            return Promise.resolve();
        }
        if (this.verbose) {
            logger.logToStderr(`Uploading converted PDF file to ${targetFileUrl}...`);
        }
        return this
            .getGraphFileUrl(logger, targetFileUrl, undefined)
            .then(targetGraphFileUrl => this.uploadFile(localFilePath, targetGraphFileUrl))
            .then(_ => Promise.resolve());
    }
    /**
     * If the user specified local file to be converted to PDF, removes the file
     * that was temporarily upload to a document library for the conversion.
     * If the specified source file was a URL, doesn't do anything.
     * @param logger Logger instance
     * @param sourceIsLocalFile Boolean that denotes if user specified a local path as the source file
     * @param sourceFileUrl Web URL of the temporary source file to delete
     */
    deleteRemoteSourceFileIfNecessary(logger, sourceIsLocalFile, sourceFileUrl) {
        // if the source was a remote file, we're done,
        // otherwise delete the temporary uploaded file
        if (!sourceIsLocalFile) {
            if (this.debug) {
                logger.logToStderr('Source file was URL. Not removing.');
            }
            return Promise.resolve();
        }
        if (this.verbose) {
            logger.logToStderr(`Deleting the temporary file at ${sourceFileUrl}...`);
        }
        return this
            .getGraphFileUrl(logger, sourceFileUrl, this.sourceFileGraphUrl)
            .then((graphFileUrl) => {
            const requestOptions = {
                url: graphFileUrl,
                headers: {
                    accept: 'application/json;odata.metadata=none'
                }
            };
            return request_1.default.delete(requestOptions);
        });
    }
}
_FileConvertPdfCommand_instances = new WeakSet(), _FileConvertPdfCommand_initOptions = function _FileConvertPdfCommand_initOptions() {
    this.options.unshift({
        option: '-s, --sourceFile <sourceFile>'
    }, {
        option: '-t, --targetFile <targetFile>'
    });
}, _FileConvertPdfCommand_initValidators = function _FileConvertPdfCommand_initValidators() {
    this.validators.push((args) => __awaiter(this, void 0, void 0, function* () {
        if (!args.options.sourceFile.toLowerCase().startsWith('https://') &&
            !fs.existsSync(args.options.sourceFile)) {
            // assume local path
            return `Specified source file ${args.options.sourceFile} doesn't exist`;
        }
        if (!args.options.targetFile.toLowerCase().startsWith('https://') &&
            fs.existsSync(args.options.targetFile)) {
            // assume local path
            return `Another file found at ${args.options.targetFile}`;
        }
        return true;
    }));
};
module.exports = new FileConvertPdfCommand();
//# sourceMappingURL=convert-pdf.js.map