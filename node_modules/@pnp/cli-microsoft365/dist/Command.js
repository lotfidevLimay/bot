"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Command_instances, _Command_initTelemetry, _Command_initOptions, _Command_initValidators;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandErrorWithOutput = exports.CommandError = void 0;
const os = require("os");
const appInsights_1 = require("./appInsights");
const Auth_1 = require("./Auth");
const Cli_1 = require("./cli/Cli");
const request_1 = require("./request");
const settingsNames_1 = require("./settingsNames");
const accessToken_1 = require("./utils/accessToken");
class CommandError {
    constructor(message, code) {
        this.message = message;
        this.code = code;
    }
}
exports.CommandError = CommandError;
class CommandErrorWithOutput {
    constructor(error, stderr) {
        this.error = error;
        this.stderr = stderr;
    }
}
exports.CommandErrorWithOutput = CommandErrorWithOutput;
class Command {
    constructor() {
        // These functions must be defined with # so that they're truly private
        // otherwise you'll get a ts2415 error (Types have separate declarations of
        // a private property 'x'.).
        // `private` in TS is a design-time flag and private members end-up being
        // regular class properties that would collide on runtime, which is why we
        // need the extra `#`
        _Command_instances.add(this);
        this.debug = false;
        this.verbose = false;
        this.telemetry = [];
        this.telemetryProperties = {};
        this.options = [];
        this.optionSets = [];
        this.types = {
            boolean: [],
            string: []
        };
        this.validators = [];
        __classPrivateFieldGet(this, _Command_instances, "m", _Command_initTelemetry).call(this);
        __classPrivateFieldGet(this, _Command_instances, "m", _Command_initOptions).call(this);
        __classPrivateFieldGet(this, _Command_instances, "m", _Command_initValidators).call(this);
    }
    get allowedOutputs() {
        return ['csv', 'json', 'text'];
    }
    validateUnknownOptions(args, command) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.allowUnknownOptions()) {
                return true;
            }
            // if the command doesn't allow unknown options, check if all specified
            // options match command options
            for (const optionFromArgs in args.options) {
                let matches = false;
                for (let i = 0; i < command.options.length; i++) {
                    const option = command.options[i];
                    if (optionFromArgs === option.long ||
                        optionFromArgs === option.short) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    return `Invalid option: '${optionFromArgs}'${os.EOL}`;
                }
            }
            return true;
        });
    }
    validateRequiredOptions(args, command) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldPrompt = Cli_1.Cli.getInstance().getSettingWithDefaultValue(settingsNames_1.settingsNames.prompt, false);
            let inquirer;
            let prompted = false;
            for (let i = 0; i < command.options.length; i++) {
                if (!command.options[i].required ||
                    typeof args.options[command.options[i].name] !== 'undefined') {
                    continue;
                }
                if (!shouldPrompt) {
                    return `Required option ${command.options[i].name} not specified`;
                }
                if (!prompted) {
                    prompted = true;
                    Cli_1.Cli.log('Provide values for the following parameters:');
                }
                if (!inquirer) {
                    inquirer = require('inquirer');
                }
                const missingRequireOptionValue = yield inquirer
                    .prompt({
                    name: 'missingRequireOptionValue',
                    message: `${command.options[i].name}: `
                })
                    .then(result => result.missingRequireOptionValue);
                args.options[command.options[i].name] = missingRequireOptionValue;
            }
            return true;
        });
    }
    validateOptionSets(args, command) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsSets = command.command.optionSets;
            if (!optionsSets || optionsSets.length === 0) {
                return true;
            }
            const argsOptions = Object.keys(args.options);
            for (const optionSet of optionsSets) {
                const commonOptions = argsOptions.filter(opt => optionSet.includes(opt));
                if (commonOptions.length === 0) {
                    return `Specify one of the following options: ${optionSet.map(opt => opt).join(', ')}.`;
                }
                if (commonOptions.length > 1) {
                    return `Specify one of the following options: ${optionSet.map(opt => opt).join(', ')}, but not multiple.`;
                }
            }
            return true;
        });
    }
    validateOutput(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.options.output &&
                this.allowedOutputs.indexOf(args.options.output) < 0) {
                return `'${args.options.output}' is not a valid output type. Allowed output types are ${this.allowedOutputs.join(', ')}`;
            }
            else {
                return true;
            }
        });
    }
    alias() {
        return;
    }
    /**
     * Returns list of properties that should be returned in the text output.
     * Returns all properties if no default properties specified
     */
    defaultProperties() {
        return;
    }
    allowUnknownOptions() {
        return;
    }
    /**
     * Processes options after resolving them from the user input and before
     * passing them on to command action for execution. Used for example for
     * expanding server-relative URLs to absolute in spo commands
     * @param options Object that contains command's options
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
    processOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    action(logger, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield Auth_1.default.restoreAuth();
            }
            catch (error) {
                throw new CommandError(error);
            }
            this.initAction(args, logger);
            if (!Auth_1.default.service.connected) {
                throw new CommandError('Log in to Microsoft 365 first');
            }
            try {
                this.loadValuesFromAccessToken(args);
                yield this.commandAction(logger, args);
            }
            catch (ex) {
                if (ex instanceof CommandError) {
                    throw ex;
                }
                throw new CommandError(ex);
            }
        });
    }
    validate(args, command) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const validate of this.validators) {
                const result = yield validate(args, command);
                if (result !== true) {
                    return result;
                }
            }
            return true;
        });
    }
    getCommandName(alias) {
        var _a;
        if (alias &&
            ((_a = this.alias()) === null || _a === void 0 ? void 0 : _a.includes(alias))) {
            return alias;
        }
        let commandName = this.name;
        let pos = commandName.indexOf('<');
        const pos1 = commandName.indexOf('[');
        if (pos > -1 || pos1 > -1) {
            if (pos1 > -1) {
                pos = pos1;
            }
            commandName = commandName.substr(0, pos).trim();
        }
        return commandName;
    }
    handleRejectedODataPromise(rawResponse) {
        const res = JSON.parse(JSON.stringify(rawResponse));
        if (res.error) {
            try {
                const err = JSON.parse(res.error);
                throw new CommandError(err['odata.error'].message.value);
            }
            catch (err) {
                if (err instanceof CommandError) {
                    throw err;
                }
                try {
                    const graphResponseError = res.error;
                    if (graphResponseError.error.code) {
                        throw new CommandError(graphResponseError.error.code + " - " + graphResponseError.error.message);
                    }
                    else {
                        throw new CommandError(graphResponseError.error.message);
                    }
                }
                catch (err) {
                    if (err instanceof CommandError) {
                        throw err;
                    }
                    throw new CommandError(res.error);
                }
            }
        }
        else {
            if (rawResponse instanceof Error) {
                throw new CommandError(rawResponse.message);
            }
            else {
                throw new CommandError(rawResponse);
            }
        }
    }
    handleRejectedODataJsonPromise(response) {
        if (response.error &&
            response.error['odata.error'] &&
            response.error['odata.error'].message) {
            throw new CommandError(response.error['odata.error'].message.value);
        }
        if (!response.error) {
            if (response instanceof Error) {
                throw new CommandError(response.message);
            }
            else {
                throw new CommandError(response);
            }
        }
        if (response.error.error &&
            response.error.error.message) {
            throw new CommandError(response.error.error.message);
        }
        if (response.error.message) {
            throw new CommandError(response.error.message);
        }
        if (response.error.error_description) {
            throw new CommandError(response.error.error_description);
        }
        try {
            const error = JSON.parse(response.error);
            if (error &&
                error.error &&
                error.error.message) {
                throw new CommandError(error.error.message);
            }
            else {
                throw new CommandError(response.error);
            }
        }
        catch (err) {
            if (err instanceof CommandError) {
                throw err;
            }
            throw new CommandError(response.error);
        }
    }
    handleError(rawResponse) {
        if (rawResponse instanceof Error) {
            throw new CommandError(rawResponse.message);
        }
        else {
            throw new CommandError(rawResponse);
        }
    }
    handleRejectedPromise(rawResponse) {
        this.handleError(rawResponse);
    }
    initAction(args, logger) {
        this.debug = args.options.debug || process.env.CLIMICROSOFT365_DEBUG === '1';
        this.verbose = this.debug || args.options.verbose || process.env.CLIMICROSOFT365_VERBOSE === '1';
        request_1.default.debug = this.debug;
        request_1.default.logger = logger;
        appInsights_1.default.trackEvent({
            name: this.getUsedCommandName(),
            properties: this.getTelemetryProperties(args)
        });
        appInsights_1.default.flush();
    }
    getUnknownOptions(options) {
        const unknownOptions = JSON.parse(JSON.stringify(options));
        // remove minimist catch-all option
        delete unknownOptions._;
        const knownOptions = this.options;
        const longOptionRegex = /--([^\s]+)/;
        const shortOptionRegex = /-([a-z])\b/;
        knownOptions.forEach(o => {
            const longOptionName = longOptionRegex.exec(o.option)[1];
            delete unknownOptions[longOptionName];
            // short names are optional so we need to check if the current command has
            // one before continuing
            const shortOptionMatch = shortOptionRegex.exec(o.option);
            if (shortOptionMatch) {
                const shortOptionName = shortOptionMatch[1];
                delete unknownOptions[shortOptionName];
            }
        });
        return unknownOptions;
    }
    trackUnknownOptions(telemetryProps, options) {
        const unknownOptions = this.getUnknownOptions(options);
        const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
        unknownOptionsNames.forEach(o => {
            telemetryProps[o] = true;
        });
    }
    addUnknownOptionsToPayload(payload, options) {
        const unknownOptions = this.getUnknownOptions(options);
        const unknownOptionsNames = Object.getOwnPropertyNames(unknownOptions);
        unknownOptionsNames.forEach(o => {
            payload[o] = unknownOptions[o];
        });
    }
    loadValuesFromAccessToken(args) {
        if (!Auth_1.default.service.accessTokens[Auth_1.default.defaultResource]) {
            return;
        }
        const token = Auth_1.default.service.accessTokens[Auth_1.default.defaultResource].accessToken;
        const optionNames = Object.getOwnPropertyNames(args.options);
        optionNames.forEach(option => {
            const value = args.options[option];
            if (!value || typeof value !== 'string') {
                return;
            }
            const lowerCaseValue = value.toLowerCase();
            if (lowerCaseValue === '@meid') {
                args.options[option] = accessToken_1.accessToken.getUserIdFromAccessToken(token);
            }
            if (lowerCaseValue === '@meusername') {
                args.options[option] = accessToken_1.accessToken.getUserNameFromAccessToken(token);
            }
        });
    }
    showDeprecationWarning(logger, deprecated, recommended) {
        const cli = Cli_1.Cli.getInstance();
        if (cli.currentCommandName &&
            cli.currentCommandName.indexOf(deprecated) === 0) {
            const chalk = require('chalk');
            logger.logToStderr(chalk.yellow(`Command '${deprecated}' is deprecated. Please use '${recommended}' instead`));
        }
    }
    warn(logger, warning) {
        const chalk = require('chalk');
        logger.logToStderr(chalk.yellow(warning));
    }
    getUsedCommandName() {
        const cli = Cli_1.Cli.getInstance();
        const commandName = this.getCommandName();
        if (!cli.currentCommandName) {
            return commandName;
        }
        if (cli.currentCommandName &&
            cli.currentCommandName.indexOf(commandName) === 0) {
            return commandName;
        }
        // since the command was called by something else than its name
        // it must have aliases
        const aliases = this.alias();
        for (let i = 0; i < aliases.length; i++) {
            if (cli.currentCommandName.indexOf(aliases[i]) === 0) {
                return aliases[i];
            }
        }
        // shouldn't happen because the command is called either by its name or alias
        return '';
    }
    getTelemetryProperties(args) {
        this.telemetry.forEach(t => t(args));
        return this.telemetryProperties;
    }
}
exports.default = Command;
_Command_instances = new WeakSet(), _Command_initTelemetry = function _Command_initTelemetry() {
    this.telemetry.push((args) => {
        Object.assign(this.telemetryProperties, {
            debug: this.debug.toString(),
            verbose: this.verbose.toString(),
            output: args.options.output,
            query: typeof args.options.query !== 'undefined'
        });
    });
}, _Command_initOptions = function _Command_initOptions() {
    this.options.unshift({ option: '--query [query]' }, {
        option: '-o, --output [output]',
        autocomplete: this.allowedOutputs
    }, { option: '--verbose' }, { option: '--debug' });
}, _Command_initValidators = function _Command_initValidators() {
    this.validators.push((args, command) => this.validateUnknownOptions(args, command), (args, command) => this.validateRequiredOptions(args, command), args => this.validateOutput(args), (args, command) => this.validateOptionSets(args, command));
};
//# sourceMappingURL=Command.js.map