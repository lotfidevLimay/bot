"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const stream_1 = require("stream");
const Auth_1 = require("./Auth");
const formatting_1 = require("./utils/formatting");
const packageJSON = require('../package.json');
class Request {
    constructor() {
        this._debug = false;
        this.req = axios_1.default.create({
            headers: {
                'user-agent': `NONISV|SharePointPnP|CLIMicrosoft365/${packageJSON.version}`,
                'accept-encoding': 'gzip, deflate'
            },
            decompress: true,
            responseType: 'text',
            /* c8 ignore next */
            transformResponse: [data => data],
            maxBodyLength: Infinity,
            maxContentLength: Infinity
        });
        // since we're stubbing requests, request interceptor is never called in
        // tests, so let's exclude it from coverage
        /* c8 ignore next 7 */
        this.req.interceptors.request.use((config) => {
            if (config.responseType === 'json') {
                config.transformResponse = axios_1.default.defaults.transformResponse;
            }
            return config;
        });
        // since we're stubbing requests, response interceptor is never called in
        // tests, so let's exclude it from coverage
        /* c8 ignore next 15 */
        this.req.interceptors.response.use((response) => response, (error) => {
            if (error &&
                error.response &&
                error.response.data &&
                !(error.response.data instanceof stream_1.Stream)) {
                // move error details from response.data to error property to make
                // it compatible with our code
                error.error = JSON.parse(JSON.stringify(error.response.data));
            }
            throw error;
        });
    }
    set debug(debug) {
        // if the value to set is the same as current value return early to avoid
        // instantiating interceptors multiple times. This can happen when calling
        // one command from another
        if (this._debug === debug) {
            return;
        }
        this._debug = debug;
        if (this._debug) {
            this.req.interceptors.request.use((config) => {
                if (this._logger) {
                    this._logger.logToStderr('Request:');
                    const properties = ['url', 'method', 'headers', 'responseType', 'decompress'];
                    if (config.responseType !== 'stream') {
                        properties.push('data');
                    }
                    this._logger.logToStderr(JSON.stringify(formatting_1.formatting.filterObject(config, properties), null, 2));
                }
                return config;
            });
            // since we're stubbing requests, response interceptor is never called in
            // tests, so let's exclude it from coverage
            /* c8 ignore next 26 */
            this.req.interceptors.response.use((response) => {
                if (this._logger) {
                    this._logger.logToStderr('Response:');
                    const properties = ['status', 'statusText', 'headers'];
                    if (response.headers['content-type'] &&
                        response.headers['content-type'].indexOf('json') > -1) {
                        properties.push('data');
                    }
                    this._logger.logToStderr(JSON.stringify(Object.assign({ url: response.config.url }, formatting_1.formatting.filterObject(response, properties)), null, 2));
                }
                return response;
            }, (error) => {
                if (this._logger) {
                    const properties = ['status', 'statusText', 'headers'];
                    this._logger.logToStderr('Request error:');
                    this._logger.logToStderr(JSON.stringify(Object.assign(Object.assign({ url: error.config.url }, formatting_1.formatting.filterObject(error.response, properties)), { error: error.error }), null, 2));
                }
                throw error;
            });
        }
    }
    get logger() {
        return this._logger;
    }
    set logger(logger) {
        this._logger = logger;
    }
    post(options) {
        options.method = 'POST';
        return this.execute(options);
    }
    get(options) {
        options.method = 'GET';
        return this.execute(options);
    }
    patch(options) {
        options.method = 'PATCH';
        return this.execute(options);
    }
    put(options) {
        options.method = 'PUT';
        return this.execute(options);
    }
    delete(options) {
        options.method = 'DELETE';
        return this.execute(options);
    }
    head(options) {
        options.method = 'HEAD';
        return this.execute(options);
    }
    execute(options, resolve, reject) {
        if (!this._logger) {
            return Promise.reject('Logger not set on the request object');
        }
        return new Promise((_resolve, _reject) => {
            (() => {
                if (options.headers && options.headers['x-anonymous']) {
                    return Promise.resolve('');
                }
                else {
                    const url = options.headers && options.headers['x-resource'] ? options.headers['x-resource'] : options.url;
                    const resource = Auth_1.Auth.getResourceFromUrl(url);
                    return Auth_1.default.ensureAccessToken(resource, this._logger, this._debug);
                }
            })()
                .then((accessToken) => {
                if (options.headers) {
                    if (options.headers['x-anonymous']) {
                        delete options.headers['x-anonymous'];
                    }
                    if (options.headers['x-resource']) {
                        delete options.headers['x-resource'];
                    }
                    if (accessToken !== '') {
                        options.headers.authorization = `Bearer ${accessToken}`;
                    }
                }
                return this.req(options);
            })
                .then((res) => {
                if (resolve) {
                    resolve(options.responseType === 'stream' ? res : res.data);
                }
                else {
                    _resolve(options.responseType === 'stream' ? res : res.data);
                }
            }, (error) => {
                if (error && error.response &&
                    (error.response.status === 429 ||
                        error.response.status === 503)) {
                    let retryAfter = parseInt(error.response.headers['retry-after'] || '10');
                    if (isNaN(retryAfter)) {
                        retryAfter = 10;
                    }
                    if (this._debug) {
                        this._logger.log(`Request throttled. Waiting ${retryAfter}sec before retrying...`);
                    }
                    setTimeout(() => {
                        this.execute(options, resolve || _resolve, reject || _reject);
                    }, retryAfter * 1000);
                }
                else {
                    if (reject) {
                        reject(error);
                    }
                    else {
                        _reject(error);
                    }
                }
            });
        });
    }
}
exports.default = new Request();
//# sourceMappingURL=request.js.map