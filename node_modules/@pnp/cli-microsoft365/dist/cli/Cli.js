"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cli = void 0;
const fs = require("fs");
const minimist = require("minimist");
const os = require("os");
const path = require("path");
const appInsights_1 = require("../appInsights");
const Command_1 = require("../Command");
const config_1 = require("../config");
const request_1 = require("../request");
const settingsNames_1 = require("../settingsNames");
const formatting_1 = require("../utils/formatting");
const fsUtil_1 = require("../utils/fsUtil");
const md_1 = require("../utils/md");
const packageJSON = require('../../package.json');
class Cli {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() {
        this.commands = [];
        this.commandsFolder = '';
    }
    get config() {
        if (!this._config) {
            const configStore = require('configstore');
            this._config = new configStore(config_1.default.configstoreName);
        }
        return this._config;
    }
    getSettingWithDefaultValue(settingName, defaultValue) {
        const configuredValue = this.config.get(settingName);
        if (typeof configuredValue === 'undefined') {
            return defaultValue;
        }
        else {
            return configuredValue;
        }
    }
    static getInstance() {
        if (!Cli.instance) {
            Cli.instance = new Cli();
        }
        return Cli.instance;
    }
    execute(commandsFolder, rawArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.commandsFolder = commandsFolder;
            // check if help for a specific command has been requested using the
            // 'm365 help xyz' format. If so, remove 'help' from the array of words
            // to use lazy loading commands but keep track of the fact that help should
            // be displayed
            let showHelp = false;
            if (rawArgs.length > 0 && rawArgs[0] === 'help') {
                showHelp = true;
                rawArgs.shift();
            }
            // parse args to see if a command has been specified and can be loaded
            // rather than loading all commands
            const parsedArgs = minimist(rawArgs);
            // load commands
            this.loadCommandFromArgs(parsedArgs._);
            if (this.currentCommandName) {
                for (let i = 0; i < this.commands.length; i++) {
                    const command = this.commands[i];
                    if (command.name === this.currentCommandName ||
                        (command.aliases &&
                            command.aliases.indexOf(this.currentCommandName) > -1)) {
                        this.commandToExecute = command;
                        break;
                    }
                }
            }
            if (this.commandToExecute) {
                // we have found a command to execute. Parse args again taking into
                // account short and long options, option types and whether the command
                // supports known and unknown options or not
                this.optionsFromArgs = {
                    options: this.getCommandOptionsFromArgs(rawArgs, this.commandToExecute)
                };
            }
            else {
                this.optionsFromArgs = {
                    options: parsedArgs
                };
            }
            // show help if no match found, help explicitly requested or
            // no command specified
            if (!this.commandToExecute ||
                showHelp ||
                parsedArgs.h ||
                parsedArgs.help) {
                this.printHelp();
                return Promise.resolve();
            }
            const optionsWithoutShorts = Cli.removeShortOptions(this.optionsFromArgs);
            try {
                // replace values staring with @ with file contents
                Cli.loadOptionValuesFromFiles(optionsWithoutShorts);
            }
            catch (e) {
                return this.closeWithError(e, optionsWithoutShorts);
            }
            try {
                // process options before passing them on to validation stage
                yield this.commandToExecute.command.processOptions(optionsWithoutShorts.options);
            }
            catch (e) {
                return this.closeWithError(e.message, optionsWithoutShorts, false);
            }
            // if output not specified, set the configured output value (if any)
            if (optionsWithoutShorts.options.output === undefined) {
                optionsWithoutShorts.options.output = this.getSettingWithDefaultValue(settingsNames_1.settingsNames.output, 'json');
            }
            const validationResult = yield this.commandToExecute.command.validate(optionsWithoutShorts, this.commandToExecute);
            if (validationResult !== true) {
                return this.closeWithError(validationResult, optionsWithoutShorts, true);
            }
            return Cli
                .executeCommand(this.commandToExecute.command, optionsWithoutShorts)
                .then(_ => process.exit(0), err => this.closeWithError(err, optionsWithoutShorts));
        });
    }
    static executeCommand(command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = {
                log: (message) => {
                    const output = Cli.formatOutput(message, args.options);
                    Cli.log(output);
                },
                logRaw: (message) => Cli.log(message),
                logToStderr: (message) => Cli.error(message)
            };
            if (args.options.debug) {
                logger.logToStderr(`Executing command ${command.name} with options ${JSON.stringify(args)}`);
            }
            // store the current command name, if any and set the name to the name of
            // the command to execute
            const cli = Cli.getInstance();
            const parentCommandName = cli.currentCommandName;
            cli.currentCommandName = command.getCommandName(cli.currentCommandName);
            try {
                yield command.action(logger, args);
                if (args.options.debug || args.options.verbose) {
                    const chalk = require('chalk');
                    logger.logToStderr(chalk.green('DONE'));
                }
            }
            finally {
                // restore the original command name
                cli.currentCommandName = parentCommandName;
            }
        });
    }
    static executeCommandWithOutput(command, args, listener) {
        return __awaiter(this, void 0, void 0, function* () {
            const log = [];
            const logErr = [];
            const logger = {
                log: (message) => {
                    const formattedMessage = Cli.formatOutput(message, args.options);
                    if (listener && listener.stdout) {
                        listener.stdout(formattedMessage);
                    }
                    log.push(formattedMessage);
                },
                logRaw: (message) => {
                    const formattedMessage = Cli.formatOutput(message, args.options);
                    if (listener && listener.stdout) {
                        listener.stdout(formattedMessage);
                    }
                    log.push(formattedMessage);
                },
                logToStderr: (message) => {
                    if (listener && listener.stderr) {
                        listener.stderr(message);
                    }
                    logErr.push(message);
                }
            };
            if (args.options.debug) {
                const message = `Executing command ${command.name} with options ${JSON.stringify(args)}`;
                if (listener && listener.stderr) {
                    listener.stderr(message);
                }
                logErr.push(message);
            }
            // store the current command name, if any and set the name to the name of
            // the command to execute
            const cli = Cli.getInstance();
            const parentCommandName = cli.currentCommandName;
            cli.currentCommandName = command.getCommandName();
            // store the current logger if any
            const currentLogger = request_1.default.logger;
            try {
                yield command.action(logger, args);
                // restoring the command and logger is done here instead of in a 'finally' because there were issues with the code coverage tool
                // restore the original command name
                cli.currentCommandName = parentCommandName;
                // restore the original logger
                request_1.default.logger = currentLogger;
                return ({
                    stdout: log.join(os.EOL),
                    stderr: logErr.join(os.EOL)
                });
            }
            catch (err) {
                // restoring the command and logger is done here instead of in a 'finally' because there were issues with the code coverage tool
                // restore the original command name
                cli.currentCommandName = parentCommandName;
                // restore the original logger
                request_1.default.logger = currentLogger;
                throw {
                    error: err,
                    stderr: logErr.join(os.EOL)
                };
            }
        });
    }
    loadAllCommands() {
        const files = fsUtil_1.fsUtil.readdirR(this.commandsFolder);
        files.forEach(file => {
            if (file.indexOf(`${path.sep}commands${path.sep}`) > -1 &&
                file.indexOf(`${path.sep}assets${path.sep}`) < 0 &&
                file.endsWith('.js') &&
                !file.endsWith('.spec.js')) {
                try {
                    const command = require(file);
                    if (command instanceof Command_1.default) {
                        this.loadCommand(command);
                    }
                }
                catch (e) {
                    this.closeWithError(e, { options: {} });
                }
            }
        });
    }
    /**
     * Loads command files into CLI based on the specified arguments.
     *
     * @param commandNameWords Array of words specified as args
     */
    loadCommandFromArgs(commandNameWords) {
        this.currentCommandName = commandNameWords.join(' ');
        if (commandNameWords.length === 0) {
            this.loadAllCommands();
            return;
        }
        const isCompletionCommand = commandNameWords.indexOf('completion') > -1;
        if (isCompletionCommand) {
            this.loadAllCommands();
            return;
        }
        let commandFilePath = '';
        if (commandNameWords.length === 1) {
            commandFilePath = path.join(this.commandsFolder, 'commands', `${commandNameWords[0]}.js`);
        }
        else {
            if (commandNameWords.length === 2) {
                commandFilePath = path.join(this.commandsFolder, commandNameWords[0], 'commands', `${commandNameWords.join('-')}.js`);
            }
            else {
                commandFilePath = path.join(this.commandsFolder, commandNameWords[0], 'commands', commandNameWords[1], commandNameWords.slice(1).join('-') + '.js');
            }
        }
        this.loadCommandFromFile(commandFilePath);
    }
    /**
     * Loads command from the specified file into CLI. If can't find the file
     * or the file doesn't contain a command, loads all available commands.
     *
     * @param commandFilePath File path of the file with command to load
     */
    loadCommandFromFile(commandFilePath) {
        if (!fs.existsSync(commandFilePath)) {
            this.loadAllCommands();
            return;
        }
        try {
            const command = require(commandFilePath);
            if (command instanceof Command_1.default) {
                this.loadCommand(command);
            }
            else {
                this.loadAllCommands();
            }
        }
        catch (_a) {
            this.loadAllCommands();
        }
    }
    static getCommandInfo(command) {
        return {
            aliases: command.alias(),
            name: command.name,
            command: command,
            options: this.getCommandOptions(command),
            defaultProperties: command.defaultProperties()
        };
    }
    loadCommand(command) {
        this.commands.push(Cli.getCommandInfo(command));
    }
    static getCommandOptions(command) {
        const options = [];
        command.options.forEach(option => {
            const required = option.option.indexOf('<') > -1;
            const optionArgs = option.option.split(/[ ,|]+/);
            let short;
            let long;
            let name = '';
            optionArgs.forEach(o => {
                if (o.startsWith('--')) {
                    long = o.replace('--', '');
                    name = long;
                }
                else if (o.startsWith('-')) {
                    short = o.replace('-', '');
                    name = short;
                }
            });
            options.push({
                autocomplete: option.autocomplete,
                long: long,
                name: name,
                required: required,
                short: short
            });
        });
        return options;
    }
    getCommandOptionsFromArgs(args, commandInfo) {
        const minimistOptions = {
            alias: {}
        };
        if (commandInfo) {
            const commandTypes = commandInfo.command.types;
            if (commandTypes) {
                minimistOptions.string = commandTypes.string;
                minimistOptions.boolean = commandTypes.boolean;
            }
            minimistOptions.alias = {};
            commandInfo.options.forEach(option => {
                if (option.short && option.long) {
                    minimistOptions.alias[option.short] = option.long;
                }
            });
        }
        return minimist(args, minimistOptions);
    }
    static formatOutput(logStatement, options) {
        if (logStatement instanceof Date) {
            return logStatement.toString();
        }
        let logStatementType = typeof logStatement;
        if (logStatementType === 'undefined') {
            return logStatement;
        }
        // we need to get the list of object's properties to see if the specified
        // JMESPath query (if any) filters object's properties or not. We need to
        // know this in order to decide if we should use default command's
        // properties or custom ones from JMESPath
        const originalObject = Array.isArray(logStatement) ? Cli.getFirstNonUndefinedArrayItem(logStatement) : logStatement;
        const originalProperties = originalObject && typeof originalObject !== 'string' ? Object.getOwnPropertyNames(originalObject) : [];
        if (options.query &&
            !options.help) {
            const jmespath = require('jmespath');
            try {
                logStatement = jmespath.search(logStatement, options.query);
            }
            catch (e) {
                const message = `JMESPath query error. ${e.message}. See https://jmespath.org/specification.html for more information`;
                Cli.getInstance().closeWithError(message, { options }, false);
            }
            // we need to update the statement type in case the JMESPath query
            // returns an object of different shape than the original message to log
            // #2095
            logStatementType = typeof logStatement;
        }
        if (!options.output || options.output === 'json') {
            return JSON
                .stringify(logStatement, null, 2)
                // replace unescaped newlines with escaped newlines #2807
                .replace(/([^\\])\\n/g, '$1\\\\\\n');
        }
        if (logStatement instanceof Command_1.CommandError) {
            const chalk = require('chalk');
            return chalk.red(`Error: ${logStatement.message}`);
        }
        let arrayType = '';
        if (!Array.isArray(logStatement)) {
            logStatement = [logStatement];
            arrayType = logStatementType;
        }
        else {
            for (let i = 0; i < logStatement.length; i++) {
                if (Array.isArray(logStatement[i])) {
                    arrayType = 'array';
                    break;
                }
                const t = typeof logStatement[i];
                if (t !== 'undefined') {
                    arrayType = t;
                    break;
                }
            }
        }
        if (arrayType !== 'object') {
            return logStatement.join(os.EOL);
        }
        // if output type has been set to 'text' or 'csv', process the retrieved
        // data so that returned objects contain only default properties specified
        // on the current command. If there is no current command or the
        // command doesn't specify default properties, return original data
        if (options.output === 'text' || options.output === 'csv') {
            const cli = Cli.getInstance();
            const currentCommand = cli.commandToExecute;
            if (arrayType === 'object' &&
                currentCommand && currentCommand.defaultProperties) {
                // the log statement contains the same properties as the original object
                // so it can be filtered following the default properties specified on
                // the command
                if (JSON.stringify(originalProperties) === JSON.stringify(Object.getOwnPropertyNames(logStatement[0]))) {
                    // in some cases we return properties wrapped in `value` array
                    // returned by the API. We'll remove it in the future, but for now
                    // we'll use a workaround to drop the `value` array here
                    if (logStatement[0].value &&
                        Array.isArray(logStatement[0].value)) {
                        logStatement = logStatement[0].value;
                    }
                    logStatement = logStatement.map((s) => formatting_1.formatting.filterObject(s, currentCommand.defaultProperties));
                }
            }
        }
        if (options.output === 'csv') {
            const { stringify } = require('csv-stringify/sync');
            const cli = Cli.getInstance();
            // https://csv.js.org/stringify/options/
            return stringify(logStatement, {
                header: cli.getSettingWithDefaultValue(settingsNames_1.settingsNames.csvHeader, true),
                escape: cli.getSettingWithDefaultValue(settingsNames_1.settingsNames.csvEscape, '"'),
                quote: cli.config.get(settingsNames_1.settingsNames.csvQuote),
                quoted: cli.getSettingWithDefaultValue(settingsNames_1.settingsNames.csvQuoted, false),
                quotedEmpty: cli.getSettingWithDefaultValue(settingsNames_1.settingsNames.csvQuotedEmpty, false)
            });
        }
        // display object as a list of key-value pairs
        if (logStatement.length === 1) {
            const obj = logStatement[0];
            const propertyNames = [];
            Object.getOwnPropertyNames(obj).forEach(p => {
                propertyNames.push(p);
            });
            let longestPropertyLength = 0;
            propertyNames.forEach(p => {
                if (p.length > longestPropertyLength) {
                    longestPropertyLength = p.length;
                }
            });
            const output = [];
            propertyNames.sort().forEach(p => {
                output.push(`${p.length < longestPropertyLength ? p + new Array(longestPropertyLength - p.length + 1).join(' ') : p}: ${Array.isArray(obj[p]) || typeof obj[p] === 'object' ? JSON.stringify(obj[p]) : obj[p]}`);
            });
            return output.join('\n') + '\n';
        }
        // display object as a table where each property is a column
        else {
            const Table = require('easy-table');
            const t = new Table();
            logStatement.forEach((r) => {
                if (typeof r !== 'object') {
                    return;
                }
                Object.getOwnPropertyNames(r).forEach(p => {
                    t.cell(p, r[p]);
                });
                t.newRow();
            });
            return t.toString();
        }
    }
    static getFirstNonUndefinedArrayItem(arr) {
        for (let i = 0; i < arr.length; i++) {
            const a = arr[i];
            if (typeof a !== 'undefined') {
                return a;
            }
        }
        return undefined;
    }
    printHelp(exitCode = 0) {
        const properties = {};
        if (this.commandToExecute) {
            properties.command = this.commandToExecute.name;
            this.printCommandHelp();
        }
        else {
            Cli.log();
            Cli.log(`CLI for Microsoft 365 v${packageJSON.version}`);
            Cli.log(`${packageJSON.description}`);
            Cli.log();
            properties.command = 'commandList';
            this.printAvailableCommands();
        }
        appInsights_1.default.trackEvent({
            name: 'help',
            properties
        });
        appInsights_1.default.flush();
        process.exit(exitCode);
    }
    printCommandHelp() {
        let helpFilePath = '';
        let commandNameWords = [];
        if (this.commandToExecute) {
            commandNameWords = (this.commandToExecute.name).split(' ');
        }
        const pathChunks = [this.commandsFolder, '..', '..', 'docs', 'docs', 'cmd'];
        if (commandNameWords.length === 1) {
            pathChunks.push(`${commandNameWords[0]}.md`);
        }
        else {
            if (commandNameWords.length === 2) {
                pathChunks.push(commandNameWords[0], `${commandNameWords.join('-')}.md`);
            }
            else {
                pathChunks.push(commandNameWords[0], commandNameWords[1], commandNameWords.slice(1).join('-') + '.md');
            }
        }
        helpFilePath = path.join(...pathChunks);
        if (fs.existsSync(helpFilePath)) {
            Cli.log();
            Cli.log(md_1.md.md2plain(fs.readFileSync(helpFilePath, 'utf8'), path.join(this.commandsFolder, '..', '..', 'docs')));
        }
    }
    printAvailableCommands() {
        // commands that match the current group
        const commandsToPrint = {};
        // sub-commands in the current group
        const commandGroupsToPrint = {};
        // current command group, eg. 'spo', 'spo site'
        let currentGroup = '';
        const addToList = (commandName, command) => {
            const pos = commandName.indexOf(' ', currentGroup.length + 1);
            if (pos === -1) {
                commandsToPrint[commandName] = command;
            }
            else {
                const subCommandsGroup = commandName.substr(0, pos);
                if (!commandGroupsToPrint[subCommandsGroup]) {
                    commandGroupsToPrint[subCommandsGroup] = 0;
                }
                commandGroupsToPrint[subCommandsGroup]++;
            }
        };
        // get current command group
        if (this.optionsFromArgs &&
            this.optionsFromArgs.options &&
            this.optionsFromArgs.options._ &&
            this.optionsFromArgs.options._.length > 0) {
            currentGroup = this.optionsFromArgs.options._.join(' ');
            if (currentGroup) {
                currentGroup += ' ';
            }
        }
        const getCommandsForGroup = () => {
            for (let i = 0; i < this.commands.length; i++) {
                const command = this.commands[i];
                if (command.name.startsWith(currentGroup)) {
                    addToList(command.name, command);
                }
                if (command.aliases) {
                    for (let j = 0; j < command.aliases.length; j++) {
                        const alias = command.aliases[j];
                        if (alias.startsWith(currentGroup)) {
                            addToList(alias, command);
                        }
                    }
                }
            }
        };
        getCommandsForGroup();
        if (Object.keys(commandsToPrint).length === 0 &&
            Object.keys(commandGroupsToPrint).length === 0) {
            // specified string didn't match any commands. Reset group and try again
            currentGroup = '';
            getCommandsForGroup();
        }
        const namesOfCommandsToPrint = Object.keys(commandsToPrint);
        if (namesOfCommandsToPrint.length > 0) {
            // determine the length of the longest command name to pad strings + ' [options]'
            const maxLength = Math.max(...namesOfCommandsToPrint.map(s => s.length)) + 10;
            Cli.log(`Commands:`);
            Cli.log();
            for (const commandName in commandsToPrint) {
                Cli.log(`  ${`${commandName} [options]`.padEnd(maxLength, ' ')}  ${commandsToPrint[commandName].command.description}`);
            }
        }
        const namesOfCommandGroupsToPrint = Object.keys(commandGroupsToPrint);
        if (namesOfCommandGroupsToPrint.length > 0) {
            if (namesOfCommandsToPrint.length > 0) {
                Cli.log();
            }
            // determine the longest command group name to pad strings + ' *'
            const maxLength = Math.max(...namesOfCommandGroupsToPrint.map(s => s.length)) + 2;
            Cli.log(`Commands groups:`);
            Cli.log();
            // sort commands groups (because of aliased commands)
            const sortedCommandGroupsToPrint = Object
                .keys(commandGroupsToPrint)
                .sort()
                .reduce((object, key) => {
                object[key] = commandGroupsToPrint[key];
                return object;
            }, {});
            for (const commandGroup in sortedCommandGroupsToPrint) {
                Cli.log(`  ${`${commandGroup} *`.padEnd(maxLength, ' ')}  ${commandGroupsToPrint[commandGroup]} command${commandGroupsToPrint[commandGroup] === 1 ? '' : 's'}`);
            }
        }
        Cli.log();
    }
    closeWithError(error, args, showHelpIfEnabled = false) {
        const chalk = require('chalk');
        let exitCode = 1;
        let errorMessage = error instanceof Command_1.CommandError ? error.message : error;
        if ((!args.options.output || args.options.output === 'json') &&
            !this.getSettingWithDefaultValue(settingsNames_1.settingsNames.printErrorsAsPlainText, true)) {
            errorMessage = JSON.stringify({ error: errorMessage });
        }
        else {
            errorMessage = chalk.red(`Error: ${errorMessage}`);
        }
        if (error instanceof Command_1.CommandError && error.code) {
            exitCode = error.code;
        }
        Cli.error(errorMessage);
        if (showHelpIfEnabled &&
            this.getSettingWithDefaultValue(settingsNames_1.settingsNames.showHelpOnFailure, showHelpIfEnabled)) {
            this.printHelp(exitCode);
        }
        else {
            process.exit(exitCode);
        }
        // will never be run. Required for testing where we're stubbing process.exit
        /* c8 ignore next */
        throw new Error();
        /* c8 ignore next */
    }
    static log(message, ...optionalParams) {
        if (message) {
            console.log(message, ...optionalParams);
        }
        else {
            console.log();
        }
    }
    static error(message, ...optionalParams) {
        const errorOutput = Cli.getInstance().getSettingWithDefaultValue(settingsNames_1.settingsNames.errorOutput, 'stderr');
        if (errorOutput === 'stdout') {
            console.log(message, ...optionalParams);
        }
        else {
            console.error(message, ...optionalParams);
        }
    }
    static prompt(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const inquirer = require('inquirer');
            return yield inquirer.prompt(options);
        });
    }
    static removeShortOptions(args) {
        const filteredArgs = JSON.parse(JSON.stringify(args));
        const optionsToRemove = Object.getOwnPropertyNames(args.options)
            .filter(option => option.length === 1 || option === '--');
        optionsToRemove.forEach(option => delete filteredArgs.options[option]);
        return filteredArgs;
    }
    static loadOptionValuesFromFiles(args) {
        const optionNames = Object.getOwnPropertyNames(args.options);
        optionNames.forEach(option => {
            const value = args.options[option];
            if (!value ||
                typeof value !== 'string' ||
                !value.startsWith('@')) {
                return;
            }
            const filePath = value.substr(1);
            // if the file doesn't exist, leave as-is, if it exists replace with
            // contents from the file
            if (fs.existsSync(filePath)) {
                args.options[option] = fs.readFileSync(filePath, 'utf-8');
            }
        });
    }
}
exports.Cli = Cli;
//# sourceMappingURL=Cli.js.map